[原文地址](https://reactjs.org/docs/design-principles.html)
### 设计原则
 
我们编写这个文档，这样你就会对我们决定 React 做什么，和 React 不做什么，还有我们的开发理念有更好的了解。尽管我们很激动可以看到社区贡献，但是我们不太可能选择一条违背一个或者多个这些原则的道路。

注意：这个文档假设对 React 有很强的理解。它描述了 React 本身的设计原则，不是 React 组件或者应用。

了解 React，查阅[了解 React](https://reactjs.org/docs/thinking-in-react.html)。

### 组合

React 的主要特性是组件的组合。不同人编写的组件应该可以一起工作很好。这对我们很重要，你可以添加功能到组件而不导致贯穿代码库的改变。

比如，引入一些本地状态到组件而不改变任何使用它的组件应该是可能的。同样的，应该可能去添加初始化或者卸载代码到任何组件，当需要的时候。

在组件内使用状态或者生命周期方法也没什么"坏的"。就像任何强大的功能，他们应该适当使用，但是我们没有意图去移除他们。相反，我们认为他们是让 React 有用的必须部分。我们可能在未来启用[更多函数式模式](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State)，但是本地状态和生命周期方法将会成为模型的一部分。

组件通常描述为"只是函数"，但是在我们看来，他们需要比这更有用。在 React 中，组件描述任何可组合的行为，这包括渲染，生命周期，和状态。一些额外库，比如 [Relay](https://facebook.github.io/relay/) 扩展组件有其他职责，比如描述数据依赖。这些想法也可能以某种形式返回 React 也是可能的。

### 通用抽象

通常我们[拒绝可以在用户态实现的添加特性](https://www.youtube.com/watch?v=4anAwXYqLG8)。我们不想使用没有使用的库代码增大你的应用。然而，有一些例外。

比如，如果 React 没有提供对本地状态或者生命周期方法的支持，人们将会创建他们自定义抽象。当有多个抽象竞争的时候，React 不能强制或者充分利用他们的属性。它需要和最小公分母一起工作。

这也就是为什么有时候添加特性到 React 本身。如果我们注意到很多组件以不兼容或者低效的方式实现了某个特性。我们可能偏向于放进 React。我们不轻易做这件事。当我们做这件事，那是因为我们确信加入这个抽象级别有助于整个生态。状态，生命周期，方法，跨浏览器事件规范化都是这个的好例子。

我们总是和社区讨论这些改善提议。你可以在 React issue 跟踪通过 ["big picture"](https://github.com/facebook/react/issues?q=is:open+is:issue+label:%22Type:+Big+Picture%22) 标签找到这些讨论。

### 逃生出口

React 是务实的。它是被 Facebook 的产品的需求驱动的。尽管它被还不是完全主流的范式影响，比如函数式编程，保持对广泛的有不同技能和经验等级的开发者访问性是项目的明确目标。

如果我们想要废弃一个我们不喜欢的模式，考虑所有存在的用户场景并且在废弃之前[向社区公布替代方案](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)是我们的责任。如果一些模式对构建应用很有帮助，但是很难使用声明式去表示，我们将[提供命令式 API](https://reactjs.org/docs/more-about-refs.html)。如果我们不能为我们在很多应用需要的提供一个更好的 API，我们将[提供一个临时工作 API](https://reactjs.org/docs/legacy-context.html)，直到之后可以摆脱它，并且留下一个通向未来改善的门。


### 稳定性

我们很重视 API 的稳定性。在 Facebook，我们有超过 50 000 个使用 React 的组件。很多其他公司，包括 [Twitter](https://twitter.com/) 和 [Airbnb](https://www.airbnb.com/)，也是 React 的重度用户。这也是为什么我们通常不愿意去改变公共 API 或者行为。

然而，我们觉得稳定性是"没有改变"太过了。它很快就进入停滞不前。相反，我们偏向于稳定性为"在生产中大量使用，当有一些东西改变的时候，以一个清晰（最好是自动的）的升级路径"。

当我们废弃一个模式，我们学习他在 Facebook 的内部使用并添加废弃警告。它让我们访问潜在的改变。有时候，我们回滚它，如果发现我们觉得它太早了，我们需要从策略的角度思考，让代码库到达为这个改变准备好的点。

如果我们对改变并不分裂并且升级策略对所有场景都适合，我们发行废弃警告到开源社区。我们接近 Facebook 之外的 React 用户，我们监控流行的开源项目，并指导他们去修复这些废弃。

考虑到 Facebook React 代码库的大小，内部成功升级通常是一个很好的指示器，意味着其他公司也不会有问题。然而，有时候，人们会指出额外的我们没有考虑到的使用场景，对这些，我们添加紧急出口，或者重新思考我们的实现方式。

我们不会无理由的废弃任何东西。我们意识到有时候废弃警告导致挫折，但是我们添加他们是为了清理提高和新特性的到来，我们和社区中的很多人都认为是值得的。

比如，我们在 React 15.2.0 添加了一个[未知 DOM 属性的警告](https://reactjs.org/warnings/unknown-prop.html)。很多项目都被这个影响了。然而，修复这个警告是很重要的，这样我们可以为 React 引入[自定义属性](https://github.com/facebook/react/issues/140)的支持。我们添加的每一个废弃都有类似的理由。

当我们添加一个废弃警告，我们在当前主版本保持它，并且[在下一个主版本改变行为](https://reactjs.org/blog/2016/02/19/new-versioning-scheme.html)。如果需要执行大量的手动工作，我们发行一个[codemode](https://www.youtube.com/watch?v=d0pOgY8__JM)脚本，自动执行大量改变。codemod 让我们在大型代码库中快速前进，而不需要停止，我们也鼓励你去使用。

你可以发现我们发行 codemod 在[codemod](https://github.com/reactjs/react-codemod)。

### 交互性

我们很看中和已存在的系统的交互行和渐进式引入。Facebook 有大量的非 React 代码库。它的网站使用一个服务端组件系统，叫做 XHP，比 React 更早的内部 UI 库，和 React 的混合。任何产品团队可以[为一个小特性开始使用 React](https://www.youtube.com/watch?v=BF58ZJ1ZQxY)而不是重写他们的代码来赌一把对我们来说很重要。

这也是为什么 React 提供和可变模型和与其他 UI 库一起使用的的紧急出口。你可以包裹一个已经存在的命令式 UI 到一个声明式组件，反之亦然。这对于渐进式引入很重要。

### 调度

尽管你的描述为函数，但你使用 React，而没有直接调用他们。每一个组件返回一个[需要渲染的描述](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree)，这个描述可能包含用户编写的组件，像`<LikeButton>`和平台指定的组件，比如`<div>`。这取决于 React 在未来某一点去"展开"`<LikeButton>`，和真实应用改变到 UI 树，基于组件的递归渲染结果。

这是一个很细微的差别，但是是最重要的一个。因为你不调用组件函数，而是让 React 调用，它意味着如果需要， React 有能力去延迟调用它。在 React 当前的实现中，React 在一个周期中递归遍历树并调用整个更新树的渲染函数。然而，在未来，它可能启用[延迟一些更新去避免掉帧](https://github.com/facebook/react/issues/6170)。

这在 React 设计中是一个常见主题。一些流行的库实现"推"方式，在新数据可以获取的时候计算被执行。然而，React 实现"拉"方式，计算可以被延迟，直到必须。

React 不是一个通用数据处理库。它是一个构建用户接口的库。我们认为它在应用中处于特殊的位置，知道哪些计算是即刻需要的，哪些不是。

如果一些东西不再屏幕中，我们可以延迟和他相关的任何逻辑。如果数据比帧率还快，我们可以合并并批量更新。我们可以为用户交互提供比不重要的后台工作更高的优先级（比如渲染刚从网络获取的新的内容），去避免掉帧。

需要明确的是，我们尚未充分利用这个，然而，像这样自由的做一些事情是我们偏向于通过调度控制的原因，也是`setState()`是异步的原因。概念上，我们认为这是"调度一个更新"。

通过调度控制对我们来说很难，如果我们让用户直接组合视图和一个基于[函数式响应编程](https://en.wikipedia.org/wiki/Functional_reactive_programming)中常见的"推"模式变体。我们想要拥有"胶水"代码。

在返回到 React 所执行的用户代码量最小是 React 的一个主要目标。这确保 React 保持调度能力，并基于它对 UI 的认知分割工作到块。

在团队内有一个笑话，React 应该被叫做"调度"，因为 React 不想变成"reactive"。

### 开发体验

提供一个好的开发体验对我们来说很重要。

比如，我们维护一个[React DevTools](https://github.com/facebook/react-devtools) 让你在 Chrome 和 Firefox 和 Chrome 检查 React 组件树。我们提供这给 Facebook 工程师和社区带来了很大的生产力增长。

我们也尝试尽可能提供有帮助的开发者警告。比如，React 在开发者模式警告你，如果你以浏览器不理解的方式嵌套标签，或者如果你在 API 上创建了一个常见的输入错误。开发者警告和相关检测是开发版版本比生产版本慢的主要原因。

Facebook 内部使用的模式帮助我们理解什么是常见错误，和怎样尽早防止他们。当我们添加新的功能，我们尝试去预见他们并警告。

### 调试

当发生错误的时候，有面包屑跟踪错误到它在代码库中的源头是很重要的。在 React，属性和状态都是面包屑。

如果你在屏幕上看到一些错误，你可以打开 React DevTools，找到负责渲染的组件，检查属性和状态是否正确。如果他们是，你知道问题在组件的`render()`函数，或者`render()`调用的函数。问题是孤立的。

如果状态是错误的，你知道问题是文件中的一个`setState()`调用导致的。这也相对简单定位和修复，因为在一个单独文件中，只有少量的`setState()`。

如果属性是错误的，你可以在检查器中向上遍历树，查找第一个通过向下传递属性"毒害井"的组件。

以当前属性和状态跟踪任何 UI 到生产它的数据的能力对 React 是非常重要的。状态不是一个"陷在"闭包和链接符，并且对 React 直接可用是一个明确的设计目标。

当 UI 是动态的，我们相信属性和状态的同步`render()`函数将调试转化猜测到无聊但有限的过程。我们希望在 React 中保留这些约束，尽管它让一些使用场景更加困难，像复杂动画。

### 配置

我们发现全局运行时配置选项会导致问题。

比如，偶尔我们会被要求实现一个类似`React.configure(options)`或者`React.register(component)`的函数。然而，这导致很多问题，我们还没有好的解决方案。

如果有人从第三方组件库调用类似的函数怎么办？如果一个 React 应用嵌入其他 React 应用，并且他们期望的配置不兼容？第三方组件怎么指定它需要的特定配置？我们认为全局配置和组合工作并不是很好。因为组合是 React 的中心，我们不在代码中提供全局配置。

然而，我们的确在构建级别提供一些全局配置。比如，我们提供分离的开发和生产构建。我们可能在未来[添加一个 profiling 构建](https://github.com/facebook/react/issues/6627)，我们也会考虑其他构建标志。

### DOM 之上

我们发现 React 的价值在于它让我们编写 bug 更少的组件，并组合的很好。DOM 是 React 的原始渲染目标，但是[React Native]()对于 Facebook 和社区都很重要。

渲染器无关是 React 设计的重要约束。它在内部表示添加一些开销。换句话说，任何核心改善都需要跨平台。

单一的编程模型让我们基于长跑组织工程师团队，而不是平台。因此这笔交易对我们来说很值得。

### 实现

我们尝试尽可能提供优雅的 API。我们不关心实现是否优化。真实世界是不完美的，在一定程度上，我们偏向于将丑陋的代码放到库内，如果这意味着用户不需要编写它。当我们执行新的代码，我们寻找正确的，性能的，提供好的开发体验的实现。优雅是次要的。

我们偏好于无聊的代码而不是聪明的代码。代码是随意可用的并且经常改变。[不引入新的内部抽象，除非绝对需要](https://youtu.be/4anAwXYqLG8?t=13m9s)是很重要的很容易移动，改变，和删除的冗长的代码比优雅的代码更好，因为抽象太早，并难以改变。

### 为工具的优化

一些常用的 API 有冗长的名字。比如，我们使用`componentDidMount()`替代`ditMount()`或者`onMount()`。这是[有意的](https://github.com/reactjs/react-future/issues/40#issuecomment-142442124)。目的是让和库的交互点变得高度可见。

在像 Facebook 一样的大型代码库，能够搜索指定 API 的使用是非常重要的。我们重视冗长的名字，特别是很少使用的功能。比如，`dangerouslySetInnerHTML`在代码审阅中很难丢失。

优化搜索也很重要，因为我们依赖[codemods]()去创建破坏性改变。我梦想要简单并安全的应用广阔的自动化改变，跨越代码库，并且唯一冗长的名字帮助我们达到这个目标。同样的，独特的名字让编写关于使用 React 不需要关心潜在错误定位的自定义[lint 规则](https://github.com/yannickcr/eslint-plugin-react)更简单。

[JSX](https://reactjs.org/docs/introducing-jsx.html)扮演类似的决策。尽管它对 React 非必须。我们为了实用和美观在 Facebook 中使用。

在我们的代码库，JSX 提供一个清晰的提示给工具，提示他们正在处理一个 React 元素树。这让添加构建时优化可能，比如[提升常量元素](https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements/)，安全的 lint 和 codemod 内部组件使用。并且[引入 JSX 源码定位](https://github.com/facebook/react/pull/6771)到警告中。

### 内部测试
我们尝试解决社区提出的问题。然而，我们可能优先人们在 Facebook 内部也遇到的问题。可能违反直觉，我们认为这是社区可以押注 React 的主要原因。

重度内部使用让我们自信 React 不会在明天消失。React 是 Facebook 为了解决问题而创建。它给公司带来实际的商业价值，并且在很多的产品中使用。[Dogfooding](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)意味着我们视觉保持敏锐，并且专注于他的前进。

这不意味着我们忽略社区提出的问题。比如，我们添加对[web 组件](https://reactjs.org/docs/webcomponents.html)和[SVG](https://github.com/facebook/react/pull/6243)的支持，尽管 React 内部不依赖他们。我们积极[听取你的观点](https://github.com/facebook/react/issues/2686)并尽我们最大的能力去[解决他们](https://reactjs.org/blog/2016/07/11/introducing-reacts-error-code-system.html)。社区是让 React 特殊的东西，我们很荣幸去反馈他们。

在 Facebook 开源很多项目之后，我们发现，尝试同时让每个人快乐产生很多不好的项目。相反，我们发现选择一小部分冠宗并专注让他们开心带来正向的影响。我也是我们对 React 做的，到目前位置，
Facebook 解决的问题已经很好的转化到开源社区。

这个方式的缺点是有时候我们无法给 Facebook 团队不需要处理的东西足够的关注，比如"getting started"体验。我们已经意识到这个，我们也在思考怎样提高，可以有益于社区的每一个人，而不导致我们在之前开源项目遇到的相同错误。



















 
























