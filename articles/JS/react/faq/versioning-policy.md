[原文地址](https://reactjs.org/docs/faq-versioning.html)
### 版本策略

React 遵循 [语义化版本（semver）](https://semver.org/)原则。

这意味着版本号 **x.y.x**:

- 当发布**重要 bug 修复**的时候，我们创建**修订发布**，通过修改 **z** 数字（比如：15.6.2 到 15.6.3）

- 当发布**新功能**或者**非重要修复**的时候，我们创建一个**副发布**，通过改变 **y** 数字（比如，15.6.2 到 15.7.0）

- 当发布**破坏性改变**的时候，我们创建一个**主发布**，通过改变 **x** 数字（比如：15.6.2 到 16.0.0）

主发布也可以包含新功能，并且任何发布都可以包含 bug 修复。

副版本最常见的发布。

这个版本策略不应用于预发布构建，在 Next 或者 Experimental 通道。[了解更多预发布](https://reactjs.org/docs/release-channels.html)。

### 破坏性改变

破坏性改变对所有人都不方便，因此我们尽量减少主发布的数量 - 比如，React 15 在 April 2016 发布，React 16 在 September 2017 发布；React 17 在 2019 之前不要期望。

相反，我们发布新功能在副版本。这意味着副版本通常比主版本更有趣，更有吸引力，尽管他们名字很低调。

### 致力于稳定

我们随着时间改变 React，我们尝试去最小化使用新功能需要的努力。当可能的时候，我们将保持旧的 API 可用，就算将它放到分离的包。比如，[mixin 已经不被鼓励很多年了](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)，但是他们今天依旧通过[create-react-class](https://reactjs.org/docs/react-without-es6.html#mixins)被支持，很多代码库依旧稳定的继续使用他们，遗留的代码。

超过百万的开发者使用 React，共同维护百万的组件。Facebook 代码库单独就有超过 5000 的 React 组件。这意味着我们需要去尽可能让升级到新版本的 React 简单；如果我们创建了巨大的改变，而没有升级路径，人们将会被困在旧版本。我们在 Facebook 自身测试这些升级 -- 如果我们的团队超过 10 个人可以单独升级 50000+ 组件，我们希望升级可以被任何使用 React 的人管理。在很多场景，我们编写[自动化脚本](https://github.com/reactjs/react-codemod)去升级组件语法，然后我们包含到开源发布给任何人使用。

### 通过警告逐步升级

React 的开发构建包含很多有帮助的警告。当可能的时候，我们添加警告，为未来的破坏性改变做准备。这意味着，如果你的应用在最新的发行中没有任何警告，它将和下一个主版本兼容。这允许你升级你的应用一次一个组件。

开发者警告不影响你的应用的运行态行为。这意味着，你可以自信你的应用将在开发和生产构建中运行一致 -- 不同的是产品构建不记录警告并且更高效。（如果你注意到其他问题，请发一个 issue）

### 什么可以认为是破坏性改变？

通常我们不会为以下改变修改版本号：

- **开发警告**。因为这不影响生产构建，我们可能在主版本之间添加新的警告或者修改存在的警告。事实上，这是允许我们可靠的警告即将到来的破坏性改变。

- **以 unstable_ 开始的 API**。这些作为体验性特性提供的 API 我们还没有自信。通过使用`unstable_`前缀发行，我们可以快速遍历，并获得稳定 API。

- **React 的 alpha 和 canary 版本**。我们提供 alpha 版本的 React 作为提早测试新功能的方式，但是我们需要弹性，基于我们从 alpha 版本学到的去改变。

- **没有文档的 API 和内部数据结构**。如果你访问到内部属性名类似`__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`或者`
__reactInternalInstance$uk43rzhitjg`，没有担保。你只能靠你自己。

这个策略是实用主义的：的确，我们不想让你头疼。如果我们为所有改变升级主版本号，我们将发布更多主版本，最终导致社区更多的版本痛苦。这也意味着我们无法像我们希望的快速改变 React。

这也就说，如果我们期待这个列表的改变将会在社区导致问题，我们将依旧尽我们最大的努力去提供逐步升级路径。

### 如果副版本不包含任何新功能，为什么它不是一个修订？

一个副发行不包含任何新功能也是可能的，[semver 允许这么做](https://semver.org/#spec-item-7)，**"[一个副版本]可能增加，如果大量新功能或者优化被引入到私有代码。它可能包含修订级别的改变。"**

然而，它的确提出了一个问题，为什么这些发行不使用修订版本代替。

回答是 React 的任何改变（或者其他软件）都有以非预期方式携带破坏性风险。想象一个场景，修复一个 bug 的修订发行意外引入了另一个 bug。这不仅仅扰乱开发者，也伤害他们对未来修订发行的信心。特别遗憾的是原始修复是为了一个实际很罕见的场景。

我们有一个足够好的跟踪记录去保证 React 发行没有 bug，但是修订发行有更高的可信赖度，因为大部分开发者假设他们可以接受，而不需要承担后果。

因为这些原因，我们保留修订发布，只用于重要 bug 和安全风险。

如果一个发行包含了不必要的变更 -- 比如内部重构，改变实现详情，性能提升，或者副版本 bug 修复 -- 我们依旧升级副版本尽管没有新功能。


























