### The Web Origin Conept

### 概述：

这个文档定义了一个“Origin”的概念，通常在认证或者用户代理权限范围内使用。通常，用户代理将不同源返回的内容隔离，防止邪恶的网页站点干涉和善的网页站点。为了概述源的基本原则和源的理念，这个文档详细描述了怎样决定一个 URI 的源和序列化一个源到一个字符串。同时也定义了一个 HTTP 头部域，名为“Origin”，这指示了一个 HTTP 请求关联的源。

### 备忘录状态

这是一个互联网标准跟踪文档。

这个文档时候互联网工程任务组的产品（IETF）。它代表了 IETF 社区的一致意见。它接收了公开的检查，并被互联网工程接待组（IESG）改善发布。关于互联网标准更多的信息可以在 RFC 5741 的章节二获取。

关于这个文档当前的状态信息，和文字错误，还有如何提供反馈可以从 http://www.rfc-editor.org/info/rfc6454 获取。

### 版权注意
用户代理交互的内容由大量的作则创建。尽管大量的作者是善意的，还是有一些可能是邪恶的。很大程度上，用户代理基于他们处理的内容采取动作，用户代理的的实现者可能希望限制邪恶作者去打破其他内容或者服务的完整性或者机密性的能力。

作为一个例子，考虑一个 HTTP 用户代理渲染从大量服务获取的 HTML 内容。如果用户代理执行包含在这些文档中的脚本，用户代理实现者可能希望阻止从邪恶服务器获取来的脚本阅读存储在实诚服务器的文档，可能，比如，隐藏在防火墙后。

通常来说，用户代理通过它的“origin”分发内容。更贴别的是，用户代理允许从一个 origin 来的内容去和这个 origin 来的其他内容自由的交互，但是用户代理限制和其他 origin 来的内容交互。

这个文档描述了 smae-origin 策略背后的原则，就像“螺母和螺栓”那样比较和序列化源。这个文档并没有描述 same-origin 策略的所有方面，详细内容在其他规则，比如 HTML，Websockets，因为细节总是应用指定。

### 2. 约定
### 2.1 标准一致性

这个文档中的关键词“MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“RECOMMANDED”，“MAY”，和“OPTIONAL”的解释被概括在 RFC2119。

必须语句作为算法的一部分（比如“删除前导空白字符”或者“返回 false 并放弃后面的步骤”）将被关键字（“MUST”，“SHOULD”，“MAY”，等）的意义解释而使用在算法的介绍中。

算法或者特定步骤的一致性需求可以使用多种方式实现，只要结果是相等的。特别是，这个规格中定义的算法旨在更加容易理解，而不是性能。

### 2.2 语法符号

这个规格使用 RFC5234 定义的增强的巴克斯范式（ABNF）语法。

下面的核心规则通过引用包含，定义在 RFC5234，附录 B.1：ALPHA(letters)，CR(回车)，CRLF(CR LF)，CTL(controls)，DIGIT(数字 0-9)，DQUOTE(双引号)，HEXDIG(十六进制 0-9/A-F/a-f)，LF(换行)，OCTET(任意 8位数据序列)，SP(空白)，HTAB(水平制表符)，CHAR(任何 US-ASCII 字符)，VCHAR(任何可见的 US-ASCII 字符)，和 WSP(空白符)。

OWS 规则用在0个或者多个水平空白八进制可能出现的地方。OWS 不应该被生产或者生产为一个单独的 SP。域内容中出现的多个 OWS 八进制应该被一个单独的 SP 替换或者在和域的值交互之前全部转化成 SP 八进制（每个不是 SP 的八进制被 SP 替换），或者向下游传输信息。

```
    OWS         = *( SP / HTAB / obs-fold ) ; "可选的"空白符
    obs-fold    = CRLF ( SP / HTAB ) ; 过时的折线 
```

### 2.3 术语
术语“用户代理”，“客户端”，“服务端”，“代理”，和”源服务器“和 HTTP/1.1 规格中的意义一致(RFC2626，章节 1.3)。

一个全局唯一标识是一个和之前存在的值完全不一样的值。比如，一个足够长的随机字符串可能是一个全局唯一标识。果 origin 的值从来不会离开用户代理，一个单调递增的用户代理本地计数器也可以作为全局唯一标识服务。

### 3. 同源策略原则

许多用户代理基于远程执行动作。比如，HTTP 用户代理遵循远程服务的重定向执行领，HTML 用户代理暴露富文档对象模型（DOM）和从远程服务器来的脚本交互。

没有任何安全模型，用户代理可能采取对其他用户或者合作方有害的行为。渐渐的，许多网页相关的技术包含一个普通的安全模型，口头上称为“同源策略”。尽管这个安全模型自然发展状态，同源策略可以被使用关键概念术语理解。这个章节表示这些理念，提供安全使用这些理念的的建议。

### 3.1 信任

同源策略通过 URI 指定信任。比如 HTML 文档设计脚本执行一个 URI：
```
   <script src="https://example.com/library.js"></script>
```
当一个用户代理处理这个元素，用户代理将会从设计的 URI 获取脚本，并使用文档的权限执行脚本。通过这种方式，文档授权它所有的权限给 URI 的资源。本质上，文档声明它信任从这个 URI 获取的信息完整性。

为了从 URI 中倒入库，用户代理也发送信息到 URI 指定的远程合作方。比如，考虑下面的 HTML 表单元素：
```
 <form method="POST" action="https://example.com/login">
    ... <input type="password"> ...
   </form>
```
当用户输入他或者他的密码并提交表单，用户代理发送密码到 URI 指定的网络。通过这种方式，文档导出它的秘密数据到这个 URI，本质上，声明他相信信息发送到的 URI 的机密性。



### 3.1.1 陷阱

当设计一个新的协议并使用同源策略的时候，确保信任可以从 URI 中获取。比如，如果安全传输层（TLS）和非 TLS 保护的资源都使用“HTTP” URI 方案（就像在 RFC2817），一个文档将无法指定他希望只通过 TLS 获取脚本。通过使用”https“ URI 方案，文档可以指示他们希望和活跃的网络攻击中保护的资源互动。

### 3.2 源
原则上，用户代理可以对待任何一个 URI 为一个分离的受保护的域名，并且需要详细的确保从一个 URI 来的内容和其他 URI 交互。不幸的是，这个设计对开发着来说非常的笨重，因为网页应用通常由一系列的资源组成。

作为替代，用户代理将 URI 分组为受保护的域，叫做“origins”。粗略来讲，两个 URI 有相同的方案，主机和端口（看第四章获取详情），那么他们是同源的一部分（比如，表示相同的原则）。

Q：为什么不只是使用主机？
A：将方案包含到源组是安全必须的。如果用户代理不包含方案，将无法区分 http://example.com 和 https://example.com，因为他们有相同的主机。然而，没有这个区分，一个活跃的网络攻击者可以污染从 http://example.com 获取到的内容并指示用户代理去损害 https://example.com 来的内容的机密性和一致性，绕过 TLS 的保护。

Q：为什么使用完整的主机名，而不是只使用“顶级”域名？
A：尽管 DNS 有层级接哦股，主机名的信任关系因部署相异。比如，很多交互机构，学生可以在 https://example.edu/~students/ 部署内容，但是这不意味着学生的内容文档应该是同源的一部分（比如，在同一个保护的域名），因为一个管理年纪的应用部署在 https://grades.example.edu/。

example.edu 通过域来分组资源的部署方式不总是和所有的部署方式一致。在这种方式中，每一个学生的网页站点在同一个域中，可能不是期望的。从某些意义来说，源的粒度是安全模型的历史产物

### 3.2.1 栗子

下面的资源是同源的：
http://example.com/
http://example.com:80/
http://example.com/path/file

每一个 URL 都有相同的方案，主机和端口组件。

下面的每一个资源和其他资源相比都有不同的源/

http://example.com/
http://example.com:8080/
http://www.example.com/
https://example.com:80/
https://exmaple.com/
http://example.org/
http://ietf.org/

在每一个场景中，都至少有一个方案，主机，和端口组件和列表中其他的不一样。

### 3.3 权限
尽管用户代理将 URI 分组到 origin，并非统一个 origin 的每一个资源都有相同的权限（在安全场景下的“权限”，而不是 RFC 3986 场景）。比如，一个图片是被动内容，因此没有任何权限，这意味着图像无法访问他的 origin 的对象和资源。相比之下，一个 HTML 文档从它的 origin 获取了所有的权限，文档内的脚本（或者倒入的）可以访问他的 origin 的任何资源。

用户代理通过检测它的媒体类型来确认一个资源被授予的权限。比如，一个拥有 image/png 媒体类型的资源被认为是图片，一个有 text/html 媒体类型的资源被认为是 HTML 文档。

当部署一个不信任的内容的时候（比如用户生成的内容），网页应用可以通过限制他的媒体类型来限制他的权限。比如，将用户生成的内容看作是 image/png比将用户生成的内容看作 text/html 来的风险更小。当然，很多网页应用将不信任的内容收纳到他们的 HTML 文档中。如果不仔细处理，这些应用有泄漏他们 origin 的权限给不信任的内容的风险，一个易受攻击的常见的就是跨站脚本。


### 3.3.1 陷阱

当设计网页平台的一部分的时候，注意不要授权给资源媒体类型。很多网页应用使用媒体类型提供不信任的内容。一个新的网页平台功能授权这部分内容引入易受攻击的风险到已经存在的应用。作为替代，授权给已经处理源所有权限的媒体类型或者设计转么携带新权限的媒体类型。

为了维护提供不正确媒体类型的服务的兼容性，有些用户代理提供了“内容嗅探”，对待内容就像他有一个和服务端提供的媒体类型不同的媒体类型。如果不小心处理，内容嗅探将陶制安全易受攻击，因为用户代理可能授权低权限媒体类型，比如图片，高权限媒体类型，比如 HTML 文档。


### 3.4 策略

通常来说，用户代理将不同的源隔离，并允许源之间受控的交流。用户来怎样提供隔离和交流的详情依赖于一些因素。

### 3.4.1 对象访问
用户代理暴露的大部分对象（比如应用程序变成接口或者 API）只能在同源访问。特别指出，从一个 URI 来的内容可以访问对象关联的从其他 URI 来的内容，如果，并且只能如果，两个 URI 属于同一个源，比如。有相同的方案，主机，端口号。

这些通用规则有一些异常，比如，HTML Location 接口的一部分可以跨源访问（比如，允许导航其他的浏览器上下文）。其他栗子，HTML 的 postMessage 接口在所有源上都可以用，为了促进跨域交流。暴露对象给外部的源是很危险的，应该只能很小心的使用，因为这样做会将这些对象暴露给潜在的攻击者。

### 3.4.2 网路访问
网络资源的访问权限取决于资源是否和尝试访问他们的内容在同一个 origin。

通常来说，从其他源读取信息是禁止的。然而，一个 origin 允许使用从其他 origin 返回的一些类型的资源。比如，一个 origin 允许从任何 origin 执行脚本，渲染图像，和应用样式表。

同样的，一个 origin 可以显示其他 origin 的内容，比如在 HTML frame 中显示 HTML 文档。网络资源可以可选的让其他 origin 读取他们的信息，比如，使用 跨域资源共享[CORS]()。在这种情况下，权限通常基于每一个 origin 授权。

发送信息到其他的 origin 是被允许的。然而，通过网络发送信息武断的格式是危险的。因为这个原因，用户代理获取文档去发送信息使用特殊的协议，比如没有自定义头部的 HTTP 请求。扩展允许的协议集合，比如，通过添加 WebSockets 的支持，需要非常小心避免引入易受攻击。

### 3.4.3 陷阱
无论何时，用户代理允许一个 origin 去和其他 origin 的资源交互，都会引入安全问题。比如，显示其他 origin 的图片泄露了他们的高度和宽度。同样的，发送网络请求到其他 origin 提升了跨站请求伪造风险。然而用户代理实现者总是权衡风险和允许跨域交互的额好处。比如，一个 HTML 用户代理阻塞跨域网络请求将会阻止它的用户尊许超链接，一个网页的核心功能。

当添加一个新的功能到一个网页平台，他可以授权给一个资源，但是不授予同一个域下的其他资源。然而，这种方式保留权限是没啥效果的，因为没有这个权限的资源可以随意获取权限，因为用户代理没有在一个域内隔资源。作为替代，权限应该授予或者保留到一个域整体（而不是一个域内的单独的资源）。

### 3.5 包含

同源策略使用 URI 去指定信任关系。URI 被分组到域，他表示保护的领域。一个域内的一些资源（比如，活跃的内容）被授予域的所有权限，然而，域内的有些资源没有授予域的权限（比如，被动内容）。携带域的权限的内容允许去在他们的域内访问对象和网络资源。这个内容同样受限授权去访问其他域的对象和网络资源，但是这些跨域权限必须小心设计避免引入安全风险。

### 4. URI 的源
URI 的域是下面算法计算的结果：
1. 如果 URI 没有使用层级元素作为命名权限或者如果 URI 不是一个绝对 URI，则生成一个新鲜的全局唯一表示并返回这个值：
    > 注意：多次对相同 URI 执行这个算法会得到不一样的结果。通常，用户代理计算域，比如一个 HTML 文档一次，并使用这个域做接下来的安全检测，而不是为每一次安全检测都计算一次。
2. 让 uri-schema 为 URI 的 schema 组件，转化为小写。
3. 如果实现不支持 uri-schema 给定的这个协议，则生成一个新的全局唯一标识，并返回值
4. 如果 uri-schema 是“file”，实现可能返回一个实现定义的值：
    > 注意：历史原因，用户代理授权给文件方案极大的权限。然而授权所有的本地文件一个如此广泛的权限会导致权限滥用攻击。一些用户代理已经成功授予本地文件基于文件夹的权限，但是这种方式没有被大范围接收。其他用户代理对每一个文件 URI 使用全局唯一标识，这是最安全的选项。
5. 让 uri-port 为 URI 主机组件，转化为小写（使用定义在[RFC4790]() 的 i;ascii-casemap 集合）
    > 注意：这个文档假设用户代理构造 URI 的时候执行在应用程序中国际化域名（DNA）并验证。特别是，这个文档假设 uri-host 将会只包含 LDH 标签，因为用户代理将会转化任何非 ASCII 标签到他们表示的 A-labels。因为这个原因，基于域的安全策略对用户代理部署的 IDNA 算法十分敏感。阅读章节8.4了解更多。
6. 如果 URI 没有端口组件
    1. 让 uri-port 为 uri-schema 给定的协议默认的端口
    否则：
    2. 让 uri-port 为 URI 的端口组件
7. 返回三元组（uri-schema，uri-host，uri-port）


### 5. 源对比

两个域是“相同的”，当且仅当，他们是相同的。特别是：
- 如果两个域是方案/主机/端口三元组，两个域是相同的当且仅当他们有相同的方案，主机，端口。
- 一个域是一个全局唯一标识，不能与方案/主机/端口三元组的域相同

两个 URI 是同源的，如果他们的域是相同的。
注意：一个 URI 并不需要和自己是同源的。比如一个 data URI [RFC2397]() 和它自身就不是同源，因为 data URI 不使用基于服务端的权限，因此有全局唯一标识作为域。

### 6. 序列化源

这个章节定义怎样将一个域序列化为 unicode [Unicode^]() 字符串和 ASCII [RFC20]() 字符串。

### 6.1 源的 UNICODE 序列化
一个域 的 unicode 序列化是下面算法返回的值：
1. 如果 origin 不是一个方案/主机/端口三元组，则返回字符串
    ```
    null
    ```
    （比如，码点序列 U+006E，U+0075，U+006C，U+006C）
    并放弃这些步骤
2. 否则，让 result 为域三元组的方案部分
3. 拼接 “://” 到 result
4. 拼接域三元组的主机的每一个部分到 result，使用 U+002E FULL STOP 码点（“.”）来分隔：
    1. 如果组件是一个 A-label，使用相应的 U-label 替代（查看[RFC5890]()和[RFC5891]()）
    2. 否则，直接使用组件
5. 如果域三元组的端口部分和域三元组方案部分给出的协议的默认端口不同：
    1. 拼接一个 U+003A COLON 码点（“:”）和给定端口，十进制，到 result
6. 返回 result

### 6.2 源的 ASCII 序列化
域的 ascii 序列化是执行下面算法返回的值：
1. 如果域不是一个方案/主机/端口三元组，则返回字符串：
    ```
    null
    ```
    （比如，码点序列 U+006E，U+0075，U+006C，U+006C）
    并放弃其他步骤
2. 否则，让 result 为域三元组的方案部分
3. 拼接 “://” 到 result
4. 拼接域三元组的主机部分到 result
5. 如果域三元组的端口部分和域三元组方案部分给出的协议的默认端口不同：
    1. 拼接一个 U+003A COLON 码点（“:”）和给定端口，十进制，到 result
6. 返回 result

### 7. HTTP 源头部域
这个章节定义了 HTTP Origin 头部域

### 7.1 语法
Origin 头部域有下面的语法
```
    origin                  = "Origin" OWS origin-list-or-null OWS
    origin-list-or-null     = %x6E %x75 %x6C / origin-list
    origin-list             = serialized-origin *( SP serialized-origin )
    serialized-origin       = schema "://" host [ ":" port ] ; <schema>, <host>, <port> 来自 [RFC 3986]()
```

### 7.2 语义
当包含在 HTTP 请求中的时候， Origin 头部域指示“导致”用户代理发送请求的域，就像触发用户代理发送请求的 API 定义的。

比如，考虑一个用户代理代表域执行脚本。如果这些脚本中的一个导致用户代理发送一个 HTTP 请求，用户代理可能使用 Origin 头部域去告诉服务端脚本执行导致用户代理发送请求时的安全上下文。

在某些场景，大量的域为用户代理发送 HTTP 请求贡献。在这些场景中，用户代理可能在 Origin 头部域列出所有的域。比如，如果 HTTP 请求被一个域初始化然后被其他域重定向，用户代理可能告诉服务端这两个域都导致用户代理发送请求。

### 7.3 用户代理要求
用户代理可能在所有的 HTTP 请求都包含 Origin 头部域

用户代理在任何请求中都必须不能包含多余一个 Origin 头部域

用户代理从“隐私敏感”上下文中发送 HTTP 请求的时候，用户代理必须发送“null”作为 Origin 头部域的值

> 注意：这个文档没有定义个隐私敏感上下文的概念。生成 HTTP 请求的应用可以指定一个上下文作为隐私敏感强制限制用户代理如何生成 Origin 头部域。

当生成一个 Origin 头部域的时候，用户代理必须负荷下列需求
- 每一个序列化域产生式在语法上必须是域的 ascii 序列化
- 没有两个连续的序列化域产生式在语法上是相同的。特别指出，如果用户代理将产生两个梁旭的序列化域，用户代理必须不生成第二个。



### 8 安全考虑

同源策略是很多用户代理安全的基石，包括浏览器。历史原因，一些用户代理尝试了其他安全模型，包括 raint trackint 和 exfiltration prevention，但是这些模型被证明在那时候很难实现（尽管最近有复兴其中一些想法的兴趣）。

同源策略的安全进化很困难，因为域理念本身在安全领域扮演很重要的角色。域本身指示隔离的单位，和其他一个满足所有的概念一样，他有缺陷。所以说，存在一些系统性的弱点，将在下面讨论。

### 8.1 DNS 依赖

在实践中，同源策略的安全依赖域名系统（DNS），因为大量 URI 方案的使用，比如 http，使用基于 DNS 的命名权限。如果 DNS 部分或者全部受损，同源策略将会无法提供应用需要的安全属性。

一些 URI 方案，比如 https，更加能抵抗 DNS 受损，因为用户代理有其他的机制，比如证书，去验证从 URI 来的内容的源。其他 URI 方案，比如 chrome-extension URI schema（查看 [CRX]() 章节 4.3），使用基于公开密钥命名权限并对 DNS 受损完全安全。

### 8.2 隔离单位

随着时间的流逝，一系列的技术都基于网页源理念作为便捷隔离单位。然而，很多今天是使用的技术比如 cookies[RFC6265]()，早于现代网页域理念，这些技术通常有不同的单位，导致漏洞。

一个可替换的方案是只使用“受控注册”域名，而不是圈梁查询域名作为隔离单位（比如，“example.com”替代“www.example.com”）。这个实践因为多种原因造成问题所以不推荐：
1. “受控注册”域概念是人类围绕 DNS 实践的功能，而不是 DNS 自身的属性。比如，日本很多自治区运行公共注册非常深入的层次。非常官方的使用“公共前缀列表”，但是这些列表很难保持更新并且实现差异很大。
2. 这个实践和 URI 方案有冲突，不使用基于 DNS 的命名权限。比如，如果给定一个 URI 方案使用公开密钥作为公共权限，“受控注册”公开密钥的概念有点无理。更糟糕的是，一些 URI 方案，比如 nttp，使用和 DNS 相反的点代理（比如，alt.usenet.kooks），并且其他使用 DNS 但是使用和常用顺序相反的标签表示（比如，com.example.www）。

最好，使用“受控注册”域名是 URI 方案，并且实现指定。最差，URI 方案不同会导致实现产生漏洞。

### 8.3 环境认证
当使用同源策略的时候，用户代理基于内容的 URI 授权，而不是基于内容指定的对象。权限从名称风力是环境权限的一个栗子，它可能导致漏洞。

考虑，比如，HTML 文档内的跨站脚本。如果一个攻击者可以注入脚本内容到一个 HTML 文档，这些脚本将会使用文档的域的权限执行，可能允许脚本访问私有信息，比如用户的医疗记录。如果，然而，脚本权限受脚本指定的对象限制，攻击者将无法得到任何注入脚本到第三方托管的 HTML 文档的任何好处。

### 8.4 IDNA 依赖和升级
同源策略的安全属性可能严重依赖于用户代理部署的 IDNA 算法。特别是，一些用户代理可能映射一些国际域名（比如，那些涉及 U+00DF 字符）到不同的 ASCII 表示，这取决于用户代理使用 IDNA2003[RFC3490]() 或者 IDNA2008[RFC5890]()

从一个 IDNA 算法升级到另一个可能需要重绘大量的安全边界线，潜在的树立新的安全边界，或者更糟，打破两个不信任实体之间的边界。改变安全边界是有风险的，因为绑定两个不信任的实体到一个源中，可能允许一个攻击另一个。

### 9 IANA 考虑

永久的信息头域仓库（看[RFC3864]()）已经更新登记了了下面：
头部域名称：Origin

适当的协议：http

作者/改变控制者：IETF

规格文档：这个文档（章节 7）