### RFC 7230 Hypertext Transfer Protocol \(HTTP/1.1\): Message Syntax and Routing

### 概述
超文本传输协议（HTTP）是一个无状态的应用级的协议，用于分发，合作，超文本信息系统。这个文档提供了 HTTP 架构的概述和它关联的术语，定义了“http”和“https”统一资源标识符（URI）方案，描述了实现相关的安全考虑。

### 这个备忘录的状态
这是一个网络标准跟踪文档。

这个文档是互联网工程任务组（IETF）的产品。它表示了 IETF 社区的一致意见。它接收了公共的审查，并已经被网络工程指导小组（IESG）批准发布。更多关于网络标准的信息可以在 RFC 5741 章节 2 获取。

这个文档当前的状态信息，任何勘误，和如何提供关于它的反馈可以在 [http://www.rfc-editor.org/info/rfc7230](http://www.rfc-editor.org/info/rfc7230) 获取。

### 版权注意
待续表示


### 1. 介绍

超文本转移协议（HTTP）是一个无状态的应用级请求/响应协议，使用可扩展的语义和自描述的信息负载和基于网络的超文本信息系统灵活交互。这个文档是构成 HTTP/1.1 的一系列文档中的第一个。

1. “消息语法和路由（Message Syntax and Routing）”（这个文档）
2. “语义和内容（Sematics and Content）”[RFC7231]
3. “条件请求（Conditional Requests）”[RFC7232]
4. “范围请求（Range Requests）”[RFC7233]
5. “缓存（Caching）”[RFC7234]
6. “认证（Authentication）”[RFC7235]

这个 HTTP/1.1 规格废弃了 RFC 2616 和 RFC 2145（在 HTTP 版本上）。这个规格也更新了使用 CONNECT 去建立一个隧道，之前定义在 RFC 2817，并定义了信息描述在 RFC 2818 的“https” URL 方案。

HTTP 对于信息系统来说是一个通用的接口协议。它设计是为了通过提供一个资源类型无关的通用接口给客户端来隐藏一个服务如何实现。同样的，服务端不需要知道每个客户端的意图：一个 HTTP 请求可以看作是独立的，而不是和特定类型的客户端关联或者预先定义的应用步骤。结果是一个协议可以有效的用在不同的上下文，它的实现可以随着时间独立发展。

HTTP 也设计用于中间人协议，和非 HTTP 信息系统传输交流。HTTP 代理和网关可以通过转化各种协议到超文本格式提供对可替代信息服务的访问，它可以被客户端以和 HTTP 服务相同的方式查看和操作。

这种灵活性的一个结果就是协议无法用术语定义接口背后发生了什么。作为替代，我们有限的定义了交流的语法，收到交流的意图，和接收者的预期行为。如果交流被认为是独立的，则成功的操作应该在服务提供的可观察的接口反应出适当的改变。然而，因为许多客户端可能同步操作并且可能目标不同，我们不能要求这些超出单个响应的改变可以被观察。

这个文档描述了 HTTP 使用或者引用的架构元素，定义了“http”和“https”URI 方案，描述了整个网路操作和连接管理，并定义了 HTTP 消息帧和转发要求。我们的目标是定义 HTTP 消息处理必须的机制，独立于消息语义，因此定义了完整的消息转化需求集合和信息转发中间人。

### 1.1 需求表达
在这个文档中的关键字“必须（MUST）”，“必须不（MUST NOT）”，“需要（REQUIRED）”，“应该（SHALL）”，“应该不（SHALL NOT）”，“应该（SHOULD）”，“应该不（SHOULD NOT）”，“推荐（RECOMMENED）”，“MAY（可能）”，“可选（OPTIONAL）”将按照 RFC2119 中的描述解释。
### 1.2 语法表示
这个规格使用 RFC5234 中增强的巴克斯范式（ABNF）符号和一个列表增强表示，定义在章节7，它允许使用‘#’操作符紧凑定义都好分割的列表（就像‘*’操作符指示重复）。附录 B 显示了扩展标准 ABNF 符号的所有列表操作符集合语法。

下面核心规则通过引用包含，就像定义在 RFC5234，附录 B.1：ALPHA（字母），CR（回车），CRLF（CR LF），CRL（control），DIGIT（数字0-9），DQUOTE（双引号），HEXDIG（16进制 0-9/A-F/a-f），HTAB（水平制表符），LF（换行），OCTET（任何 8 比特数据序列），SP（空格），和 VCHAR（任何可见的 USASCII 字符）

按照惯例，ABNF 规则名添加“obs-”前缀表示“废弃”语法规则，因为历史原因出现。

### 2. 架构
HTTP 为万维网（WWW）架构创建，并为支持世界范围的超文本系统的伸缩性需求随着时间进化。
### 2.1 客户端/服务端信息
HTTP 是无状态的请求/响应协议，通过在可信赖的传输或者会话层“连接”（章节6）交换信息（章节 3）操作。一个 HTTP “客户端”是一个为了发送一个或多个请求，建立到服务端的连接的程序。HTTP “服务端”是一个通过发送 HTTP 响应为了服务 HTTP 请求接受连接的程序。

术语“客户端（client）”和“服务端（server）”指的只是这些程序为特定连接执行的角色。相同的程序可能在某些连接表现的像一个客户端，而某些连写表示的像服务端。术语“用户代理（user agent）”指的只是许多初始化一个请求的程序，包括（但是不限于）浏览器，爬虫（基于网络的机器人），命令行工具，自定义应用，和手机应用。术语“原始服务器（origin server）”指的是可以为指定资源发起权威性响应的程序。术语“发送者（sender）”和“接收者（recipient）”分别指的是发送或者接受给定信息的任何实现。

HTTP 依赖统一资源标识符（URI）标准 RFC3986 去指示目标资源 章节 5.1 和资源之间的关系。消息通过类似于互联网邮件 RFC5322 和多目标互联网邮件扩展（MIME）RFC2045（查看 RFC7231 的附录 A 了解 HTTP 和 MIME 消息的不同）。

大部分 HTTP 通信好汉一个获取请求（GET），用于表示 URI 定义的一些请求。在最简单的场景中，这可能通过在用户代理（UA）和原始服务器（O）之间单个双向的连接（===）完成。
```
        request     >
    UA =================================== O
                            < response
```

客户端以请求消息的形式发送一个 HTTP 请求到服务器，以包含一个方法，URI，和协议版本的请求行开始（章节 3.1.1），跟随着头部域，包含请求定义，客户端信息，和元数据表示（章节 3.2），一个空行指示头部章节的结束，最后一个消息体包含负载体（如果有，章节 3.3）。

一个服务端通过发送一个或者多个 HTTP 响应信息响应客户端请求，每一个以包含协议版本，一个成功或者错误的码，和文字的原因语句的状态行为开始（章节 3.1.2），可能跟随着头部域，包含服务端信息，资源元数据，和元数据表示（章节3.2），一个空行表示头部章节的结束，最后是一个包含负载体的消息体（如果存在，章节 3.3）

一个章节可能用于多个请求/响应交换，定义在章节 6.3。

下面的栗子绘制一个在 URI “http://www.example.com/hello.txt”上的 GET  请求典型信息交换：

客户端请求：
```
    GET /hello.txt HTTP/1.1
    User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.71 zlin/1.2.3
    Host: www.example.com
    Accept-Language: en, mi
```
服务端响应：
```
    HTTP/1.1 200 OK
    Date: Mon, 27 Jul 2009 12:28:53 GMT
    Server: Apache
    Last-Modified: Web, 22 Jul 2009 19:15:56 GMT
    ETag: "34aa387-d-1568eb00"
    Accept-Range: bytes
    Content-Length: 51
    Vary: Accept-Encoding
    Content-Type: text/plain

    Hello World! My payload includes a trailing CRLF.
```

### 2.2 实现多样性
当考虑 HTTP 的设计的时候，很容易落入一个陷阱，认为所有的用户代理都是通用目的的浏览器，所有的源服务器都是巨大的公共网站。实际情况并非如此。常见用户代理包含家用器具，立体声，天平，固件升级脚本，命令行程序，移动应用，和在多种形状和大小的通信设备。同样的，常见 HTTP 源服务器包含家用自动单元，可配置的网路哦组件，办公机器，自动化机器人，新闻流，交通照相机，广告选择器，和视频分发平台。

术语“用户代理（user agent）”不意味着在请求的时候有一个人类用户直接交互的软件代理。在很多场景中，一个用户代理被安装或者被配置去在后台运行，保存结果为了接下来的检查（或者只保存这些结果的子集合，可能是感兴趣的或者错误的）。爬虫，比如，通常给定一个开始 URI，并配置爬取网页作为超文本图的确定行为。

HTTP 实现的多样性意味着并使所有的用户代理可以给他们的用户提出互动建议，或者提供足够的安全或者隐私问题警告。在很少的场景中，这个规格需要报告错误给用户，这些报告只能在错误控制台或者日志文件可以观察是可以接受的。同样的，在处理之前被用户处确认的自动动作可能通过高级配置选项，运行时选项或者简单的回避不安全动作可以遇见；确认并不意味着指定的用户接口或者普通处理终端如果用户已经且人了选项。

### 2.3 中介
HTTP 允许使用中介去满足请求，通过一系列的连接。有三种常形式的 HTTP 中介：代理，网关和隧道。在某些场景中，一个单独的中介可能表现为一个源服务端，代理，网关，或者隧道，基于每个请求的行为切换行为
```
        >           >           >           >
    UA ========= A ========= B ========= C ========= O
              <           <           <           <
```
上面的图像显示 3 个在用户代理和源服务端之间的中介（A，B，和 C）。一个请求或者响应的信息哦你给过 4 个分离的连接在整个链中传输。一些 HTTP 交流选项可能只接受连接最近的，没有隧道的邻居，或者链的终点，或者链中的所有连接。尽管图像是先行的，每一个部分可能参与多个，同步的交流。比如，B 可能从 A 之外的许多客户端接受请求，并且/或者转发请求到除了 C 之外的服务端，同时还处理 A 的请求。同样的，后面的请求可能通过不同的连接路径发送，经常基于均衡代理动态配置。

术语“上行流（upstream）”和“下行流（downstream）”用来描述消息流相关的定向需求：所有的消息从上行流到下行流。术语“入站（inbound）”和“出站（outbound）”用来描述请求如喽相关的定向需求：“入站（inbound）”意味着朝着服务端“出站（outbound）”意味着朝着用户代理。

一个“代理（proxy）”是一个用户代理选择的信息转发代理，通常通过本地配置规则，去接受一些类型的绝对 URI 的请求并尝试通过 HTTP 接口转化去满足这些请求。一些请求是非常小的，比如为“http” URI的代理请求，然而其他请求可能需要转化为完全不同的应用等级的协议。代理通常用来分组一个组织的 HTTP 请求，通过一个常见的中介为了安全起见，注释服务，或者缓存分享。一些代理设计用于被转发接受转化为选中的消息或者负载，描述在章节 5.7.2。

所有应用于源服务端的的 HTTP 需求对于网关的出站交流都适用。一个网关和入站服务的交流使用任何他渴望的协议，包括不再这个规格内的私有的 HTTP 扩展。然而，一个 HTTP 到 HTTP 的网关和第三方 HTTP 服务交互的时候网关入站连接应该符合用户代理需求。

一个“隧道（tunnel）”在两个连接之间表现的像不修改信息的忙转发。一旦激活，一个隧道不被认为是 HTTP 会话的一部分，尽管隧道可能通过一个 HTTP 请求初始化，一个隧道在依赖的连接双端都关闭的时候停止。隧道用来通过一个中介扩展一个虚拟连接，比如当传输层安全（TLS，RFC5246）用来建立秘密会话，通过一个分享的防火墙代理。

上面分类的中介只被认为这些表现为 HTTP 会话的参与者。还有一些中介可以在更低层次的网路协议栈行动，过滤或者重定向 HTTP 交通，不需要消息发送者的知识或者权限。网络中介是和中间人攻击是难以区分的，常常引入安全缺陷或者互通性问题，因为错误的验证 HTTP 语义。

比如，一个“拦截代理（interception proxy）” [RFC3040]（也称为“透明代理transparent proxy” [RFC1919] 或者“强制门户（captive portal）”）和 HTTP 代理是不同的，因为他不是通过客户端选择的。作为替代，一个拦截代理过滤或者重定向出去的 TCP 端口 80 包（偶尔还有其他的端口交通）。拦截代理通常可以在公共网络受理点可以找到，作为强制账户先订阅蔡恩感允许使用非本地互联网服务的手段，在企业防火墙内实施网络使用策略。

HTTP 定义为无状态的协议，意味着每一个请求消息可以独立的理解。每一个依赖于 HTTP 无状态设计的实现为了重用代理连接或者动态负载均衡请求创月镀铬服务器。因此，一个服务但必须不假设两个在同一个连接的请求是从同一个用户代理来的，除非连接是安全的并且是代理指定的。一些非标准的 HTTP 扩展（比如，[RFC4559]）违反了这些要求，导致安全和互操作性问题。



### 2.4 缓存

一个“缓存（cache）”是一个缓存之前响应信息的本地存储，控制它的信息存储，获取，和删除的子系统。一个缓存存储可以缓存的响应，为了减少响应时间和未来的网络频率损耗，相当于请求。任何客户端或者服务端可能晴空缓存，尽管当表现为一个隧道时候一个缓存不能被服务端使用。

缓存的效果是缩短请求/响应的链，如果链中的参与者对于请求有缓存的响应。下面绘制了一个请求如果 B 有一个上一次请求 O（通过 C）的响应的缓存副本，没有被 UA 或者 A 缓存的结果。
```
        >       >
    UA ====== A ====== B ------ C ----- O
            <        <
```
一个响应是“可缓存的（cacheable）”如果一个缓存被允许存储一个响应信息的副本，用来会因接下来序列的请求。当一个响应可缓存的时候，缓存的响应在用于特定的请求的时候，客户端或者服务端还可能存在额外的限制。缓存行为和可缓存响应的 HTTP 要求定义在 [RFC7234] 的章节 2。

有各种各样架构和配置的缓存部署跨域万维网和巨大组织内部。包括国家级别的代理缓存，为了节约跨洋带宽，广播或者多播缓存条目的协作系统，打包预获取缓存条目在离线或者高延迟环境使用，等等。


### 2.5 一致性和错误处理

### 2.6 协议版本
HTTP 使用一个“<major>.<monor>”数字方案去指定协议的版本。这个规格定义了版本“1.1”。协议版本指示发送者是否满足这个 HTTP 版本的规格的一系列需求。

一个 HTTP 消息的版本是通过消息的第一行的 HTTP 版本域指定的。HTTP 版本是大小写敏感的
```
    HTTP-version    = HTTP-name "/" DIGIT "." DIGIT
    HTTP-name       = %x48.54.54.50 ; "HTTP", 大小写敏感
```
HTTP 版本数字由两个小数数字组成，使用“.”分离（句点或者小数点）。第一个数字（“主版本”）指示信息的语法，第二个数字（“次版本”）指示发送者在接下来的会话中能够理解的主版本的最高次版本。次版本说明发送者交流能力，就算发送者只使用向后兼容的协议子集，因此让接收者知道更多高级特性可以在响应中使用（通过服务）或者在接下来的请求（通过客户端）。

当一个 HTTP/1.1 信息被发送到一个 HTTP/1.0 接收者[RFC1945] 或者一个接收者的版本位置，HTTP/1.1 消息的构造允许他被解析为一个有效的 HTTP/1.1 消息，如果忽略所有的新功能。这个规格将接收者版本需求放在某些新功能上，这样一个一致的发送者只使用兼容的功能，直到它被决定，通过配置或者消息的收据，接收者支持 HTTP/1.1。

一个头部域的解释在相同主要 HTTP 版本的次要版本之间应该相同，尽管一个接收者在这些域缺省的时候的默认行为可以改变。除非指定，否则定义在 HTTP/1.1 定义的头部域是为所有的 HTTP/1.x 版本定义的，特别是，Host 和 Connection 头部域应该被所有的 HTTP/1.x 实现者实现，不管他们是否旋床兼容 HTTP/1.1。

新的头部域可以引入而不改变协议版本，如果他们定义的语法允许他们安全的被接收者忽略而不认出他们。头部域的扩展在章节 3.2.1 讨论。

处理 HTTP 消息的中介（比如，所有不表现为隧道的中介）必须在转发的消息中发送他们自己的 HTTP 版本。换句话说，不允许去盲转发 HTTP 消息的第一行，在没有确认消息中协议的版本匹配和接收者和发送者的版本兼容。转发一个 HTTP 消息没有重写 HTTP 版本可能会导致交流错误当下行流接收者使用信息发送者版本去决定那些功能在接下来和发送者的绘画中是安全的。

一个客户端应该发送一个和客户端版本兼容最高版本的请求，他的祝版本没有比服务端支持的最高版本高。一个客户端必须不发送一个他不兼容的版本。

一个客户端可能发送一个低请求版本，如果他知道服务端不正确的实现了 HTTP 规格，但是只有在客户端至少尝试一个正常请求并从响应状态码或者头部域（比如，Server）决定服务端不适合处理高请求版本。

一个服务端应该发送一个响应版本等于或者大于服务端兼容版本，它的主版本小于或者等于请求接收到的。一个服务端可以发送一个 505（HTTP 版本不支持）响应如果它希望，因为一些原因，去拒绝服务客户端的主协议版本。

一个服务端可能发送 HTTP/1.0 响应给一个请求，如果他知道或者推测客户端不正确的实现了 HTTP 规格，并且无法正确的处理接下来版本的响应，比如当一个客户端转化版本数失败或者当一个中介盲转化 HTTP 版本，当它不兼容给定的次版本协议。协议降级应该不执行除非触发特定客户端属性，比如当一个或者多个头部域（比如，User-Agent）唯一命中客户端发送的只是一个错误。

HTTP 版本设计的目的是只有在不兼容的消息语法被引入的时候才增加主版本号。此版本号只有在改变让协议又增加信息语法的效果或者暗示发送者有额外的能力。然而，此版本号从 [RFC2068] 到 [RFC2616] 都没有增加过，这个修改特意避免对协议产生任何这类的改变。

当一个 HTTP 消息被一个主版本号被接收者实现，但是次版本号比接收者高的时候，接收者应该以接收者主版本中接收者兼容的最高次版本一样处理这个消息。一个接收者可以假设一个来自高次版本的消息发送给一个不支持更高版本的发送者的时候，是足够向后兼容的，可以被任何主版本的实现安全的处理。

### 2.7 统一资源标识符

统一资源标识符（URI）[RFC3986] 贯穿 HTTP，用来标识资源（[RFC7231 章节2]）。URI 引用用来标识目标请求，指示重定向，定义关系。

“URI 引用（URI-引用）”，“绝对 URI（absolute-URI）”，“相对部分（relative-part）”，“方案（schema）”，“认证（authority）”，“端口（port）”，“主机（host）”，“可空路径（path-abempty）”，“部分（segment）”，“查询（query）”，“片段（segment）”的定义来自 URI 通用语法。“绝对路径（absolute-path）”规则是为协议元素定义的，包含一个非空的路径组件。（这个规则和 RFC 3986 的可空路径有点不同，它允许一个空路径在引用中使用，绝对路径规则，不允许以“//”开始）。一个"部分 URI（partial-URI）"规则是为协议元素定义的，可以包含一个相对 URI 但是不包含片段组件。

```
    URI-reference   = <URI-reference 查阅 [RFC3986] 章节 4.1>
    absolute-URI   = <absolute-URI 查阅 [RFC3986] 章节 4.1>
    relative-part   = <relative-part 查阅 [RFC3986] 章节 4.1>
    schema   = <schema 查阅 [RFC3986] 章节 4.1>
    authority   = <authrigy 查阅 [RFC3986] 章节 4.1>
    uri-host   = <host 查阅 [RFC3986] 章节 4.1>
    port   = <port 查阅 [RFC3986] 章节 4.1>
    path-abempty   = <port 查阅 [RFC3986] 章节 4.1>
    segment   = <segment 查阅 [RFC3986] 章节 4.1>
    query   = <query 查阅 [RFC3986] 章节 4.1>
    fragment   = <fragment 查阅 [RFC3986] 章节 4.1>
```
HTTP 中的每一个允许 URI 引用的协议元素都将在它的 ABNF 产生式中指定该元素允许的引用格式（URI 引用），只有绝对格式的 URI（absolute-URI），只有路径和可选的查询组件，或者前面的组合。除非有其他指定，URI 引用转化为有效的请求 URI（章节 5.5）

### 2.7.1 http URI 方案

在这里定义 “http” URI 方案是为了铸造一个标识符，基于他们关联的层级命名空间，被潜在的 HTTP 服务管理，该服务在给定端口监听 TCP（[RFC0793]）连接。
```
    http-URI    = "http:" "//" authority parh-abempty [ "?" query] [ "#" fragment ]
```

一个 “http” 源服务通过认证组件定义，包含一个主机标识符和一个可选的 TCP 端口（[RFC3986]，章节 3.2.2）。层级路径组件和可选的查询组件作为潜在目标资源的标识符。可选的片段组件允许间接指定次级资源，不依赖 URI 方案，定义在 [RFC3986] 的章节 3.5。

一个发送者必须不生成一个空主机标识符的“http” URI。一个处理这类 URI 引用的接收者必须拒绝他就像不合法。

如果提供的主机标识符是一个 IP 地址，源服务器是该 IP 地址指定 TCP 端口的监听者。如果主机是一个注册的名字，注册的名字是一个间接标识符，使用名字解析方案，比如 DNS，找出一个源服务的地址。如果端口子组件是空的或者并未给出，默认 TCP 端口是 80（WWW 服务保留端口）。

注意，一个有给定认证组件的 URI 存在并不暗示这总是有一个 HTTP 服务在主机和端口监听连接。任何人可以铸造一个 URI。决定一个认证组件的是谁正确的对目标标识资源进行权威响应。注册名称的代理性质委托和 IP 地址创建一个联合命名空间，通过控制主机和端口的指定，不论一个 HTTP 服务是否存在。查阅章节 9.1 了解创建认证的安全考虑。

当一个“http” URI 在访问指定资源的上下文使用的时候，一个客户端可能尝试访问将主机转化为 IP 地址。建立一个 TCP 连接到这个指定端口的地址。并发送一个 HTTP 请求消息（章节3）包含 URI 的表示数据（章节5）到服务端。如果服务不是使用一个临时的 HTTP 响应消息响应请求，在 [RFC7231] 的章节6描述，则这个响应被认为客户端的请求的权威响应。

尽管 HTTP 是独立于传输协议的，“http”方案对基于 TCP 服务是特殊的，因为名字代理处理依赖 TCP 建立认证。一个 HTTP 服务基于一些其他底层连接协议大概会标识一个不同的 URI 方案，比如“https”方案（下面）用于需要端对端安全连接的资源。其他协议可能也用来提供对“http”标识资源的访问 -- 只有专门用于 TCP 的全文接口。

权威的 URI 通用语法也包含一个不推荐的用户信息子组件（[RFC3986]，章节 3.2.1），用来在 URI 中包含用户认证信息。一些实现在内部认证信息的配置使用用户信息组件，比如在命令调用选项，配置文件，或者书签列表，尽管这么使用可能暴露用户标识或者密码。一个发送者必须不生成用户细腻子组件（和它的“@”定界符），当一个“http" URI 引用在作为请求目标的信息内生成或者头部域的值。在使用一个来自不信任的源的”http" URI 引用的时候，一个接收者应该转化用户信息，并当作一个错误；它很有可能用来掩盖钓鱼工具。

### 2.7.2 https URI 方案
这里定义的 “https” URI 方案是为了铸造标识符，基于他们关联的层级命名空间，被潜在的 HTTP 源服务管理，它们为了 TLS 安全链接监听给定的 TCP 端口。

列在上面的所有“http”方案的要求对“https”方案都适用，除了 TCP 端口 443 是端口子组件默认值，如果该组件是空或者没有给定，用户代理必须保证它和服务端的链接是安全的，通过适用抢加密，端对端，在发送第一个 HTTP 请求之前。
```
    https-URI = "https:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```
注意“https” URI 方案依赖于 TLS 和 TCP 建立认证。通过“https”方案访问的资源不能和“http”方案分享，就算他们资源标识符指定相同的认证（相同的主机监听相同的 TCP 端口）。他们是不同的命名空间并且被认为和源服务器不同。然而，一个 HTTP 的扩展定义应用于整个主机域名，比如 Cookie 协议 [RFC6265]，允许信息通过一个服务设置，这暗示和其他服务的交流在同一个主机域内。

权威访问一个“https”表示的资源的处理流程定义在 [RFC
2818]。


### 2.7.3 http 和 https URI 规范化和比较

因为“http”和“https”方案和 URI 通用语法一致，这些 URI 基于定义在 [RFC 3986] 的章节 6 的算法标准化和比较，使用前面每个方案的默认描述。

如果端口和一个方案的默认端口相同，普通格式是缺省端口子组件。当不再绝对格式中用作一个 OPTION 请求的请求目标，一个空的路径组件和“/”绝对路径相等，所以，普通格式是提供一个“/”替代。方案和主机是大小写不敏感的，通常使用小写；所有其他组件以大小写敏感方式比较。除了“保留”集合中的字符外，其他字符和他们的百分比编码八位字节相同：普通格式是不编码他们（查看[RFC3986]的章节 2.1 和 2.2）

比如，下面 3 个 URI 是相等的：
```
    http://example.com:80/~smith/home.html
    http://EXAMPLE.com/%7Esmith/home.html
    http://EXAMPLE.com:/%7esmith/home.html
```

### 3. 信息格式

所有的 HTTP/1.1 消息由开始行，后面跟随着一系列互联网消息格式类似的 8 比特：0 个或者多个头部域（统称为“headers”或者“头部章节”），空行只是头部章节的结束，和一个可选的消息体。
```
    HTTP-message    = start-line
                      *( header-field CRLF )
                      CRLF
                      [ message-body ]
```
转化一个 HTTP 消息的常规的流程是读取开始行到一个结构，通过域名称读取每一个头部域到一个哈希表直到空行，然后使用转化的数据去决定是否有消息题。如果消息体被指定，则像一个流一项读取，直到八位位组的数量和读取的消息体的长度一致或者链接被关闭。

一个接收者必须转化一个 HTTP 消息位一系列的八位位组，他使用 US-ASCII 的超集编码。转化一个 HTTP 消息位一个 Unicode 字符流，不需要考虑特殊编码，因为不同字符串处理程序处理不合法的包含八位位组 LF（%x0A）多字节字符序列有多种方式，因此会创建安全漏洞。基于字符串转化器只能在从消息内解析出来的协议元素内安全使用，比如在消息转化划定哥哥域之后的一个头部域值。

一个发送者必须不在开始行和第一个头部域发送空格。一个接收者接收到在开始行和第一个头部域之间的空格必须当作无效消息拒绝或者消耗每一个前置空格行，而不处理它（比如，忽略所有行，随着接下来前置空格的行，直到何时格式的头部域被接收到或者头部章节结束）。

请求中这样的空格可能尝试欺骗服务器，让它忽略这个域或者处理下一行为一个新的请求，这可能会导致安全漏洞，如果请求链中其他实现对消息的解释不同。同样的，响应中这类的空格可能会被一些客户端忽略或者导致其他客户端停止解析。

### 3.1 开始行
一个 HTTP 消息可以是一个从客户端到服务端的请求后者一个从服务端到客户端的响应。句法上，两种类型的消息的不同只在于开始行，一个是请求行（对于请求），一个是状态行（对于响应），和决定消息体长度的算法（章节 3.3）。

理论上，一个客户端可能接收请求，一个服务端可以接收响应，通过不同的开始行格式来区分他们，但实际上，服务端只实现期望一个请求（一个响应被解释为位置或者无效的请求方法），一个客户端只实现期望一个请求。
```
    start-line  = request-line / status-line
```

### 3.1.1 请求行
一个请求行以方法令牌开始，跟随者一个单独的空格（SP），请求目标，其他单独空格（SP），协议版本，以 CRLF 结束。
```
    request-line    = method SP request-target SP HTTP-version CRLF
```
方法令牌指定在目标资源上执行的请求方法。请求方法是大小写敏感的。
```
    method  = token
```

定义在这个规格的请求方法可以在 [RFC7231] 的章节4找到，还有关于 HTTP 方法注册和定义新方法的有关事项信息。

请求目标表示应用在请求的目标资源，定义在章节 5.3。

接收者通常转化请求行到它的组件部分，通过分割空格（查看章节 3.5），因为这三个组件不允许存在空格。不幸的是，一些用户代理失败的适当编码或者排除在超文本引用内找到的空格，导致这些不允许的字符被发送到一个请求目标。

一个不合法的请求行的接收者应该响应一个正确编码的请求目标，使用 400（Bad Request）错误或者一个 301（Move Permanently）重定向。一个接收者应该不尝试自动更正并处理请求，而没有重定向，因为不合法的请求行可能故意精心制作绕过请求链的安全过滤器。

HTTP 没有限制请求行的长度，定义在章节 2.5。一个服务端接收到方法长于他实现的应该响应一个 501（Not Implemented）状态码。一个服务端接收到一个请求目标长于任何 URI 他希望转化的必须响应一个 414（URI Too Long）状态码（查看章节 [RFC7231] 6.5.12）。

请求行长度的的各种临时限制在实践中可以找到。所有的 HTTP 发送者和接收者支持的请求行最低长度是 8000 八位位组。


### 3.1.2 状态行

响应的第一行是状态行，由协议版本，一个空格（SP），状态码，其他空格，一个可能的空文本段落描述状态码，并使用 CRLF 结束。
```
    status-line = HTTP-version SP status-code SP reason-phrase CRLF
```
状态码元素是一个3位数字码描述服务端去理解和满足客户端的响应请求的结果。剩余的响应消息被基于状态码语义定义解释。查看 [RFC7231]的章节6 关于状态码语义的信息，包括状态码的类（通过第一个数字），这个规格定义的状态码，考虑新状态码的定义，和 IANA 注册。
```
    status  = 3DIGIT
```

原因语句元素独立存在的目标是为了提供一个数字状态码关联的文字描述，大部分出于尊重早期互联网应用协议更多和文字客户端交互。一个客户端应该忽略远影语句内容
```
    reason-phrase   = *( HTAB / SP / VCHAR / obs-text )
```

### 3.2 头部域
每一个头部域由大小写不敏感的域名，后面跟着一个冒号（“:”），可选的领导空格，域值，和可选的尾部空格。
```
    header-field    = field-name ":" OWS field-value OWS
    field-name      = token
    field-value     = *( field-content / obs-fold )
    field-content   = field-vchar [ 1 * ( SP / HTAB ) field-vchar ]
    field-vcahr     = VCHAR / obs-text
    obs-fold        = CRLF 1*( SP / HTAB )
                    ; 废弃的行折叠
                    ; 查阅 章节 3.2.4
```

field-name 令牌标记相符的 field-value 为头部域定义的语义。比如，Date 头部域定义在[RFC7231] 的章节 7.1.1.2，包含消息出现的起源时间。

### 3.2.1 域扩展性
头部域是完全可扩展的：引入新的域名没有限制，每一个可能定义了新的语义，或者在给定消息中头部域的数量。存在的域定义在这个规格的每个部分，和不在这个文档集合的其他规格。

新的头部域可以这样定义，当他们被接收者理解，他们可能覆盖或者增强之前定义的头部域的解释，定义请求评估的先决条件，或者提炼响应的意义。

一个代理必须转发不被意识到的头部域，除非域名被列在 Connection 头部域（章节 6.1），或者代理抓门配置去堵塞，或者其他转化，比如域。其他接收者应该忽略不认识的头部域。这些需求允许 HTTP 的功能去增强，而不需要实现升级部署的中介。

所有定义的头部域应该在 IANA 的“消息头部”仓库注册，定义在 [RFC7231] 的章节 8.3。

### 3.2.2 域顺序

接收到的有不同域名的头部域的顺序不重要。然而，先发送包含控制数据的头部域是比较好的时间，比如请求中的 Host 和响应中的 Date，这样实现可以越可能越早决定何时处理消息。一个服务端必须不应用一个请求到目标资源，知道整个请求头部章节被接收，因为后续的头部域可能包含条件，认证证书，或者鼓励错误引导重复的头部域可能暗示请求处理。

一个发送者必须不在消息中生成多个有相同域名的头部域，除非头部域的整个域值定义为逗号分割的列表[比如，#(values)]或者头部域是一致的异常（在下面有记录）。

一个接收者可能合并多个有相同域名的头部域到一个“域名：域值”对，不改变消息的语义，通过按顺序拼接每一个子序列域值到合并的域值，使用逗号分割。有相同域名的头部域接收到的顺序对于合并域值的解释是非常重要的；一个代理在转化一个消息的时候必须不改变这些域值的顺序。

注意：实际上，“Set-Cookie”头部域（[RFC6265]）在响应消息中经常出现很多次，并且不使用列表语法，违反了上面多个头部域有相同名字的需求。因为他不能被合并到一个单独的域值，接收者应该处理“Set-Cookie”作为一个特殊的栗子，当处理头部域的时候。（查看 [Kri2001] 的附录 A.2.3 了解详情）




### 3.2.3 空格

这个规格使用三条规则去表示水平空格：OWS（可选空格），RWS（需要的空格），和 BWS（“坏的”空格）。

OWS 规则用在零个或者多个水平空格八位位组出现的时候。对于协议元素，可选的空格是提升可读性首选，一个发送者应该生成可选空格为单个 SP；否则，一个发送者应该不生成可选的空格，除非需要在消息过滤的时候清除无效或者不想要的协议元素。

RWS 规则使用在至少一个水平空格八位位组需要去分离域令牌。一个发送者应该生成 RWS 为一个单独的 SP。

BWS 规则用在由于历史原因语法允许可选的空白。一个发送者在消息内必须不生成 BWS。一个接收者必须转化这种坏的空格，并在解释协议元素的时候移除他。
```
    OWS     = *( SP / HTAB )
            ; 可选的空白
    RWS     = 1*( SP / HTAB )
            ; 需要的空格
    BWS     = OWS
            ; “坏的”空格
```

### 3.2.4 域转化
消息使用通用的算法转化，不依赖单独的头部域名。给定域值的内容不被转化，知道消息解释的最后一个阶段。所以，这个规格不使用 ABNF 规则去定义每一个“域名：域值”对，就像之前的版本。作为替代，这个规格使用基于每一个注册的域名命名的 ABNF 规则，其中规则为这个域定义有效的语法表示域值（比如，在域值通过通用域转化器被从头部章节解析出来以后）。

头部域名和冒号之间不允许空格。在过去，请求路由和响应处理这类空格的不同处理导致安全风险。一个服务必须使用一个 400（Bad Request）响应码拒绝任何接收到的在头部域名和冒号之间包含空格的请求消息。一个代理在转发消息下行的时候必须从响应移除任何这类的空格。

一个域值前面或者后面可能有可选的空格（OWS）；域值前面一个单独的 SP 是为人类提供一致可读性的首选。域值不包含任何前置或者后置的空白：OWS 出现在域值的第一个非空格八位位组或者最后一个非空格八位位组之后应该被转化器排除，当从头部域解析域值的时候。

由于历史原因，HTTP 头部域可以扩展为多行通过在每一个额外的行的前面添加至少一个空格或者水平制表符（obs-fold）。这个规格启用这类行折叠，除了在 message/http 媒体类型（章节 8.3.1）中。一个发送者必须不生成包含行折叠（比如，任何包含命中 obs-fold 规则的域值），除非消息用于 message/http 媒体类型包装。

一个服务端接收到一个包含 obs-fold 但是不再一个 message/http 容器内的的请求消息必须通过发送一个 400（Bad Request），最好解释一下废弃的行折叠是不可接受的，或者使用一个或者多个 SP 八位位组替换每一个接收到的 obs-fold 在解释域值或者下行转发消息之前。

一个代理或者网关在接收到一个包含 obs-fold 但是不在一个 message/http 容器内的响应消息必须将消息废弃，并使用一个 502（Bad Gateway）响应代替，最好还有一个接收到不可接受的行折叠的解释，或者替换每一个接收到的 obs-fold 为一个或者多个 SP 八位位组在解释域值或者向下转发消息之前。

一个代理或者网关在接收到一个包含 obs-fold 但是不在一个 message/http 容器内的响应消息必须替换每一个接收到的 obs-fold 为一个或者多个 SP 八位位组，在解释域值之前。

一个代用户代理在接收到一个包含 obs-fold 但是不在一个 message/http 容器内的响应消息必须替换每一个接收到的 obs-fold 为一个或者多个 SP 八位位组，在解释域值之前。

由于历史原因，HTTP 允许域内容在 ISO-8859-1 的字符，支持其他字符值通过使用 [RFC2047] 编码。在实践中，大部分 HTTP 头部域值值使用 US-ASCII 字符集[USASCII]。新定义的头部域应该限制他们域值为 US-ASCII 八位位组。一个接收者应该对待其他域内容内的八位位组(obs-text)为透明数据。

### 3.2.5 域限制

HTTP 没有预先限制每一个头部域的的长度或者整个头部章节的头部，描述在章节 2.5。独立头部域长度的各种临时限制可以在实践中找到，通常取决于特定的域语义。

一个接收到请求头部域的服务端，或者域集合，大于他想要去处理的必须相异个适当的 4xx（Client Error）状态码。忽略这类头部域会增加服务端的请求走私攻击漏洞。

一个客户端可能抛弃或者缩短接收到的头部域大于客户端希望处理的，如果这类域语义抛弃值可以安全的忽略而不改变消息帧或者响应语义。

### 3.2.6 域值组件

大部分 HTTP 头部域值使用普通语法组件定义（令牌，引用字符串，和评论），使用空格或者特定界定字符分离。界定福从 US-ASCII 虚拟字符集合中选出，不在（DQUOTE 和 "(),/:;<=>?@[\\]{}）。
```
    token   = 1*tchar
    tchar   = "!" / "#" / "$" / "&" / "'" / "*" 
            / "+" / "-" / "." / "^" / "_" / "`" / "|" / "|"  / "~" 
            / DIGIT / ALPHA
            ; 任何 VCHAR，除了界定符
```

评论可以包含在一些 HTTP 头部域，通过使用括号包裹评论文字。评论给只允许在域包含“评论”作为他们域只定义的一部分。
```
    comment     = "(" * ( ctext / quoted-pair / coment ) ")"

    ctext       = HTAB / Sp / %x21-27 / %x2A-5B /%x5D-7E / obs-text
```

反斜杆（“\”）可以用作单个八位位组引用机制在引用字符串和评论结构内。接收者处理引用字符串的只必须处理引用对就像他被反斜杆之后的八位位组替代。
```
    quoted-pair     = "\" ( HTAB / SP / VCHAR / obs-text )
```

一个发送这不应该生成一个引用对，在一个引用字符串，除了必须去引用 DQUOTE 和反斜杆八位位组出现在字符串内。一个发送者应该不生成一个引用对在评论，除了需要应用括号[“(”和“)”]和反斜杆八位位组出现在评论内。

### 3.3 消息体
HTTP 消息的消息体（如果存在）用来运输请求或者响应的负载体。消息体和负载体是一样的，除非传输编码被应用，定义在章节 3.3.1。
```
    message-body    = *OCTET
```
消息体何时允许在消息中对于请求和响应是不同的。

请求中的消息体的表示是由 Content-Length 或者 Transfer-Encoding 头部域发出信号的。请求消息帧和方法语义独立，就算方法定义不需要使用消息体。

响应的消息体的表示依赖请求方盒和响应的状态码（章节 3.1.2）。HEAD 请求方法（[RFC7231] 的章节 4.3.2）的响应永远没有消息体，因为关联的响应头部域（比如，Transfer-Encoding，Content-Length，等），如果存在，只是指示他们的值是啥，如果请求方式是 GET（[RFC7231]的章节 4.3.1）。CONNECT 请求响应 2xx（Successful）切换到隧道模式，替换为有消息体。所有 1xx（Infomational），204（No Content），和 304（Not Modified）响应不包含消息体。所有其他响应包含消息体，尽管体可能是0长度。

### 3.3.1 传输编码

Transfer-Encoding 头部域列出了传输编码名字，表示应用于负载体的传输编码序列，为了去组织消息体。传输编码定义在章节 4。
```
    Transfer-Encoding   = 1#transfer-coding
```

Transfer-Encoding 类似于 MIME 的 Content-Transfer-Encoding 域，设计用于通过7比特传输服务（[RFC2045]，章节 6）安全传输二进制数据。然而，安全传输对于干净8比特传输协议的关注点不同。在 HTTP 的场景中，Transfer-Encoding 主要用来精确的界定动态生成负载和将只用于传输效率或者安全的有效负债编码和所选的资源的特征区分。

一个接收者必须能够转化 chunked 传输编码（章节 4.1），因为它在帧消息中扮演一个重要的决策，当负载体大小提前未知的时候。一个发送者对于一个消息体必须不应用串多于一次（比如，分块一个已经分串的信息是不允许的）。如果有其他非 chunked 传输编码应用于请求负载体，发送者必须应用 chunked 作为最后的传输编码，确保消息被适当封帧。如果任何非 chunked 的传输编码应用于响应负载体，发送者必须应用 chunked 作为最后传输编码或者关闭连接来终止消息。

比如
```
    Transfer-Encoding: gzip, chunked
```

指示当封帧消息体的时候，负载体使用 gzip 编码之后使用 chunked 编码分块。

不像 Content-Encoding（[RFC7231]的章节 3.1.2.1），Transfer-Encoding 是消息的属性，而不是表示，任何请求/响应链中的接收者可能解码接收到的传输编码或者应用额外传输编码到消息体，假设 Transfer-Encoding 域值有响应的改变。额外的编码参数信息可以由没有定义在这个规格被、的其他头部域提供。

Transfer-Encoding 可能被发送在一个 HEAD 请求的响应，或者在一个 GET 请求的304（Not Modified）响应（[RFC7232]的章节 4.1），两者都不包含消息体，指示源服务器应用传输编码到消息体，如果请求有一个无条件的 GET。这个指示不是必须的，因此，因为链的响应的接收者（包括源服务器）可以移除传输编码，当他们不需要的时候。

一个服务器必须不发送一个 Transfer-Encoding 域在任何状态码是 1xx（Infomation）或者 204（Not Content）。一个服务器必须不发送 Transfer-Encoding 头部域在任何 2xx（Successfual）响应给一个 CONNECT 请求（[RFC7231]的章节4.3.6）。

Transfer-Encoding 在 HTTP/1.1添加。通常假设 HTTP/1.0 的实现者无法理解如何处理传输编码的负载。一个客户端必须不发送一个请求包含 Transfer-Encoding，除非他知道服务端将会处理 HTTP/1.1（或者更新）的请求；这些致死后可能以指定用户配置或者记录之前接收到的响应的版本的方式。一个服务端必须不发送一个响应包含 Transfer-Encoding 除非相应的请求指定 HTTP/1.1（或者更新）。

一个服务端接收到有传输编码的请求消息，如果它无法理解，应该响应 501（Not Implemented）。

### 3.3.2 内容长度

当一个消息没有提供 Transfer-Encoding 头部域，一个 COntent-Length 头部域可以以八位位组的小数数字为潜在的负载体提供期望的大小。对于包含负载体的消息，Content-Length 域值提供了决定体（消息）结束必要的帧信息。对于没有包含负载体的消息，Content-Length 指示选中表现的大小（[RFC7231]的章节3）。
```
    Content-Length  = 1*DIGIT
```
一个栗子：
```
    Content-Length: 3495
```

一个发送者必须不在包含 Transfer-Encoding 的任何消息内发送一个 Content-Length 头部域。

一个用户代理应该发送一个 Content-Length 在一个请求消息中，如果没有 Transfer-Encoding 被发送，并且请求方法定义包含负载体。比如，一个 Content-Length 头部域通常发送在一个 POST 请求，就算值是0（指示一个空的负载体）。一个用户代理应该不发送一个 Content-Length 头部域名，当请求消息不包含一个负载体并且方法域名不期望这么一个正文。

一个服务端可能发送一个 Content-Length 头部域在给 HEAD（[RFC7231]的章节4.3.2） 请求的响应中；一个服务端必须不发送一个 Content-Length 在这类响应中，除非它的域值等于在响应的负载体内发送的八位位组的小数数字，如果相同的响应使用 GET 方法。

一个服务端可能发送一个 Content-Length 头部域在一个给条件的 GET 请求（[RFC7231]的章节4.1）的304（Not Modified）响应中；一个服务端必须不发送 Content-Lenght 在这类响应中，除非它的域值等于相同请求的200（OK）响应中发送的负载体的八位位组小数数字。

一个服务端必须不发送一个 Content-Length 头部域在任何状态码为 1xx（Infomaitonal）或者 204（No Content）的响应。一个服务端必须不发送一个 Content-Length 头部域在任何给 CONNECT 请求（[RFC
7231]的章节 4.3.6）的 2xx（Successfaul）响应。

除了前面定义的场景，如果没有 Transfer-Encoding，一个源服务端应该发送 Content-Length 头部域，当负载正文大小在发送王政头部章节之前一致。这允许下游接收者去策略船速好进度，知道何时接受消息完成，潜在的为额外的请求重用连接。

任何 Content-Lenght 域值大于或者等于0是有效的。因为没有预先定义的限制在一个负载的长度智商，一个接收者必须预料潜在的大小数数字并防止因为数字转化溢出转化失败（章节 9.3）。

如果接收到有多个 Content-Length 头部域，它的域值由多个小数值构成，或者一个单独的 Content-Length 头部域，它的域值包含一个标识小数值（比如，“Content-Length: 42, 42”），表示重复的 Content-Length 头部域被上有消息处理器生成或者合并，接收者必须当作不合法拒绝，或者替换重复的值为单独的有效的 Content-Length 域，包含小数值预先决定消息正文的长度或者转发消息。

注意：HTTP对消息帧使用 Content-Length 和使用 MIME 相同域有写不同，它只是“message/external-body”媒体类型中的可选域。



### 3.3.3 消息正文长度

消息正文的长度决定于下面的其中一个（正序）：
1. 任何 HEAD 请求的响应，任何状态码是 1xx（Infomational），204（No Content），或者 304（Not Modified）的响应总是在头部域后的第一个空行终止，无视消息中表示的头部域，从而无法包含消息正文。

2. 任何给一个 CONNECT 请求的 2xx（Successful）响应暗示连接将会称为一个隧道，在完成头部域之后的空行。一个客户端必须忽略任何 Content-Length 或则会 Transfer-Encoding 头部域戒恶兽在这些消息。

3. 如果存在一个 Transfer-Encoding 头部域并且 chunked 传输是最后编码，消息正文的长度决定于读取和解码分块的数据，知道传输编码只是数据完成了。

如果一个 Transfer-Encoding 头部域在响应中存在，并且 chunked 传输编码不是最终编码，消息正文长度取决于读取连接，知道服务端关闭。如果 Transfer-Encoding 头部域存在在一个请求，并且 chunked 传输编码不是最终编码，消息正文长度无法可信的决定；服务端必须响应 400（Bad Reqeust）状态码然后关闭连接。

如果接收到的消息中包含 Transfer-Encoding 和一个 Content-Length 头部域，Transfer-Encoding 覆盖 Content-Length。这类信息可能表示下哟个执行请求走私（章节 9.5）或者响应分割（章节 9.4），应该处理为一个错误。一个发送者必须移除接收到的 Content-Length 域，在向下转发这类消息的时候。

4. 如果接收到的消息没有 Transfer-Encoding 并且有多个 Content-Length 头部域名有不同的域值，或者单个 Content-Length 头部域有一个不合法的值，则消息帧是不合法的，接收者必须对待它像不可恢复的错误。如果这是一个请求消息，服务端必须相异个 400（Bad Request）状态码，并关闭连接。如果这是一个响应，被一个代理接受，代理必须关闭连接到服务端，废弃接收到的响应，并发送 502（Bad Gateway）响应到客户端，如果这是一个响应消息，被用户代理接受，用户代理必须关闭连接到服务端，并废弃接收到的响应。

5. 如果一个有效的 COntent-Length 头部域存在，并且没有 Transfer-Encoding，它的小数值定义了期待的消息正文长度的八位位组。如果发送者关闭了连接或者接收者在指定八位位组数字之前超时，接收者必须卡率消息未完成并关闭连接。

6. 如果这是一个请求消息，并且切面的都不是 true，则消息的长度为0（没有消息正文存在）。

7. 否则，这是一个没有生命消息正文长度的响应消息，所以消息正文的长度取决于服务端关闭之前接收到的八位位组的数量。

因为没有方法去区分成功的完成，关闭-界定消息的部分接收到的消息被网络错误中断，一个服务端应该任何时候尽可能生成编码或者长度界定的消息。关闭界定的功能存在主要是为了兼容 HTTP/1.0

除非一个不是 chunked 的传输编码被应用，一个客户端发送的包含消息正文的请求应该使用一个有效的 Content-Length 头部域，如果消息正文实现知道，而不是分块传输编码，因为一些存在的服务使用 411（Length Required）响应 chunked，尽管他们理解 chunked 传输编码。这主要因为这些服务通过网关显现，需要一个事先知道的内容长度调用，服务无法或者不希望缓存整个请求，在处理之前。

一个用户代理应该发送一个请求，包含请求正文，必须发送一个有效的 Content-Length 头部域，如果它不知道服务端将会处理 HTTP/1.1（或者更新）的请求；这些只是应该在特定用户配置或者记录先前接受到的响应的版本的形势下。

如果连接最后请求的最终响应被完整的接受，还有额外的数据去读取，一个用户代理应该放弃剩下的数据，或者尝试去决定，如果那个数据属于先前响应正文的一部分，可能先前的 Content-Length 值不正确。一个客户端必须不处理，缓存，或者转发额外的数据作为分离的响应，因为这类行为可能导致缓存污染。

### 3.4 处理不完整的信息

一个服务端接受到一个不完整的请求消息，通常因为一个取消的请求或者触发一个超时异常，可能发送一个错误响应，在关闭连接之前。

一个客户端可能接收到不完成的响应消息，可能出现在连接关闭过早的关闭，或者当解码一个推测 chunked 传输编码失败，必须记录消息为不正确。不完整响应的缓存需要定义在[RFC7234]的章节3。

如果一个响应在头部章节的中间终止，状态码可能依赖头部域去表达响应完整的含义，则客户端不能假设剩下的已经表达完成了；客户端可能需要按需重复请求去决定下一步做什么。

使用 chuanked 传输编码的消息正文是为完成的，如果0大小的分块终止没有被接收到。一个消息使用不合法的 Content-Length 是不完整的，如果接受到的消息正文的大小小于 Content-Length 给定的值。一个响应没有 Content-Length 或者不是 chunked 传输编码被连接关闭终止，因此，考虑完成无视接受到的消息正文八位位组的数量，前提是完整接受了表头。

### 3.5 消息转化鲁棒性

旧的 HTTP/1.0 用户代理实现可能发送额外的 CRLF 在 POST 请求作为早期服务端应用的变通方法，读取不是行结束的消息正文内容失败。一个 HTTP/1.1 用户代理必须不使用额外的 CRLF 作为开头或者结束。如果期望使用行终结符戒恶书请求消息正文，则用户代理必须将结束的 CRLF 八位位组计入，作为消息正文长度的一部分。

为了鲁棒性，一个服务端期待接受和转化一个请求行应该忽略至少一个空行（CRLF），在接收到请求行之前。

尽管开始行的行终结符和头部域是 CRLF 序列，一个接收者可能认出一个单独的 LF 作为行终结符并忽略前置的 CR。

尽管请求行和状态行语法规则需要每一个组件元素使用 SP 八位位组分离，接收者可能替代使用空白包裹分割转化除了 CRLF 终止副，对待任何形式的空白为 SP 的分割，当hulue前置或者后继空白；这类空格包含一个或者多个的八位位组：SP，HTAB，VT（%x0B），FF（%x0C），或者只是 CR。然而，宽容的转化导致安全风险，如果多个消息的接收者有他自己独立的鲁棒性解释（查看章节 9.5）。

如果一个服务端只监听 HTTP 请求消息，或者处理任何出现在开始行为一个 HTTP 请求消息，接受一系列的八位位组不满足 HTTP 消息语法，除了前面的鲁棒性异常列表，服务端应该使用 400（Bad Request）响应。

### 4. 传输编码
传输编码名字用来表示一个编码传输已经，可以，或者可能需要去用于负载正文，为了确保“安全传输”通过网络。这和内容编码不同，传输编码是消息的属性，而不是传输表示的属性。
```
    transfer-coding     = "chunked" ; 章节 4.1
                        / "compress" ; 章节 4.2.1
                        / "deflate" ; 章节 4.2.2
                        / "gzip" ; 章节 4.2.3
                        / transfer-extension 
    transfer-parameter  = token *( OWS ";" OWS tansfer-parameter )
```

参数是以 name 或者 name-value 对的形式
```
    transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

所有传输编码名是大小写不敏感的，应该注册在 HTTP Transfer Coding 仓库，定义在章节 8.4。他们使用在 TE（章节 4.3）和 Transfer-Encoding（章节 3.3.1）头部域。

### 4.1 分块传输编码

chunked 传输编码包裹负载正文，为了像一系列分块传输，每一个都有自己的大小指示器，跟随一个可选的包含头部域的尾挂。chunked 让未知大小的内容流可以像长度界定缓存序列一样传输，让一个发送者保留持久化，让接收者知道什么时候可以接受到整个信息。
```
    chunked-body    = *chunk
                      last-chunk
                      trailer-part
                      CRLF
    chunk           = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
    chunk-size      = 1*HEXDIG
    last-chunk      = 1*("0") [ chunk-ext ] CRLF
    chunk-data      = 1*OCTET ; 一个序列的 chunk-size 八位位组
```

chunk-size 域是一个十六进制数字，指示 chunk-data 八位位组的大小。chunked 传输编码在接受到 chunk-size 为 0 的 chunk 收到的时候完成了，可能跟随着一个尾挂，最后以一个空行作为终结。

一个接收者必须可以转化和解码 chunked 传输编码。

### 4.1.1 分块扩展

chunked 编码允许每一个分块包含0个或者多个分块扩展，跟随在 chunk-size 之后，为了提供每一个块的元数据（比如签名或者哈希），中间消息控制信息，或者消息正文大小随机化。
```
    chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
    chunk-ext-name  = token
    chunk-ext-val   = token / quoted-string
```

chunked 编码是针对每个连接的，每一个接收者可能移除或者重新编码（包含中介），在任何更高级别应用都有机会去肩擦扩展。因此，分块扩展通常限制在指定的 HTTP 服务，比如“long polling”（这样客户端和服务端可以分享分块扩展的使用的考虑），或者填充一个端到端安全连接。

一个接收者必须忽略不认识的分块扩展，一个服务端应该去限制接收到的请求的分块扩展的长度为服务提供的合理长度，他应用长度限制和超时为消息的其他部分，生成适当的 4
xx（客户端错误）响应，如果总量超过了。

### 4.1.2 分块尾挂部分

一个尾挂允许发送者包含额外的域，在一个 chunked 消息的结果，为了应用可能在消息体发送之后动态生成的元数据，比如一个消息完整性检查，数字签名，或者状态后期处理。尾挂域就是头部域，除了他们发送在分块尾挂，而不是消息的头部章节
```
    trailer-part    = *( header-field CRLF )
```

一个发送者必须不生成一个尾挂，包含一个消息帧必须的域（比如，Transfer-Encoding 和 Content-Length），路由（比如，Host），请求修改（比如，[RFC7231]的章节5的控制和条件），认证（比如，查看[RFC7235]和[RFC6165]），响应控制数据（比如，查看[RFC7231]章节 7.1），或者决定如何处理负载（比如，Content-Encoding，Content-Type，Content-Range，和 Trailer）。


当接收到一个 chunked 消息包含一个非空的尾挂的时候，接收者可能处理域（除了前面禁止的），就像他们是拼接在消息的头部章节一样。一个接收者必须忽略任何禁止在尾挂中发送的域，因为像在头部章节一样处理他们可能绕过外部的安全过滤器。

除非请求包含一个 TE 头部域指定“trailers”是被接受的，定义在章节4.3，一个服务端应该不生成他认为对于用户代理是必须的尾挂域。没有一个 TE 包含“trailers”，服务端应该假设尾挂域应该静默抛弃，在去用户代理的路径上。这个需求允许中间转发一个非 chunked 消息到 HTTP/1.0 接收者，不需要缓存整个响应。

### 4.1.3 分块解码
一个处理 chunked 传输编码的解码可以用以下为代码表示：
```
     length := 0
     read chunk-size, chunk-ext (if any), and CRLF
     while (chunk-size > 0) {
        read chunk-data and CRLF
        append chunk-data to decoded-body
        length := length + chunk-size
        read chunk-size, chunk-ext (if any), and CRLF
     }
     read trailer field
     while (trailer field is not empty) {
        if (trailer field is allowed to be sent in a trailer) {
            append trailer field to existing header fields
        }
        read trailer-field
     }
     Content-Length := length
     Remove "chunked" from Transfer-Encoding
     Remove Trailer from existing header fields
```
### 4.2 压缩编码
下面定义的编码可以用来压缩一个消息的负载
### 4.2.1 Compress 编码
“compress”编码是一个自适应的 Lempel-Ziv-Welch（LZW）编码[Welch]，通常由 UNIX 文件压缩程序“compress”。一个接收者应该认为“x-compress”和“compress”相等。
### 4.2.2 Deflate 编码
“deflate”便是是一个“zlib”数据格式[RFC1950]包含一个“deflate”压缩数据流[RFC1951]，使用 Lempel-Ziv（LZ77）压缩算法和哈哈夫曼编码的结合。

注意：一些不一致的实现发送“deflate”压缩数据而不是用 zlib 包裹。
### 4.2.3 Gzip 编码
“gzip”编码是一个 LZ77 编码，带一个 32 位的循环冗余检测（CRC），通常由 gzip 文件压缩程序[RFC1952]产生。一个接收者应该认为“x-gzip”和“gzip”相同。
### 4.3 TE

请求中的“TE”头部域指定什么传输编码，除了 chunked，客户端愿意在响应中接受，客户端是否愿意接受尾挂域在一个 chunked 传输编码。

TE 域值由一系列逗号分割的传输编码名字列表构成，每一个都语序可选的参数（描述在章节4），和/或关键字“trailers”。一个客户端必须不在 TE 内发送 chunked 传输编码名字；chunked 对于 HTTP/1.1 接收者总是可接受的。
```
    TE          = #t-codings
    t-codings   = "trailers" / ( transfer-cofing [ t-ranking ] )
    t-rankong   = OWS ";" OWS "q=" rank
    rank        = ( "0" [ "." 0*3DIGIT ] )
                / ( "1" [ "." 0*3("0") ] )
```
下面是使用 TE 的3个栗子
```
    TE: deflate
    TE:
    TE: trailers, deflate;q=0.5
```
关键字“trailers”的存在指示客户端愿意在 chunked 传输编码中接受尾挂域，定义在章节 4.1.2，代表自己和任何下行客户端。对于来自中介的请求，这意味着两者：（a）所有的下游客户端愿意接受尾挂域在转发的响应；或者，（b）中介将会代表下游接收者尝试去缓存响应。注意 HTTP/1.1 不定义任何分块响应的大小限制，这样中介可以保证缓存整个响应。

当多个传输编码是可接收者，客户端可能对编码排名通过使用一个大小写不敏感的“q”参数（类似内容谈判域中 q 值的使用，[RFC7231] 的章节 5.3.1）。等级值是一个0到1之间的实数，0.001 是最小的选择，1是最大的选择；一个 0 值意味着“不可接受”。

如果 TE 域值是空的，或者没有 TE 域存在，可接受的传输编码是 chunked。一个没有传输编码的消息总是可接受的。

因为 TE 头部域只被立即连接接受，一个 TE 的发送者必须发送一个“TE“连接选项在 Connection 头部域（章节 6.1），为了防止 TE 域被不支持它的语义的中介转发。

### 4.4 Trailer

当一个包含一个消息体的消息使用 chunked 传输编码，并且发送者期望在消息的地步以尾挂域的形式发送元数据，发送者应该生成 Trailer 头部域，在消息正文之前只是哪个域将会在尾挂中存在。这允许接收者准备接受元数据，在处理正文之前，这对于消息是流并且接收者希望确认机密性检测的时候，
```
    Trailer = 1#field-name
```

### 5. 消息路由

HTTP 请求消息路由决定于每一个客户端，基于目标资源，客户端的代理配置，和建立或者重用一个入站连接。相应的响应路由遵循相同的链接链返回客户端。

### 5.1 标识一个目标资源

HTTP 用于各种各样的应用，范围从通用目的计算机到家庭应用。在某些场景中，会话选项是应编码在客户端的配置。然而，大部分 HTTP 客户端依赖相同的资源标识机制和配置技术，计算通用目的的网页浏览器。

HTTP 会话为了某些目的通过用户代理初始化。目标是请求语义的混合，定义在 [RFC7231]，一个目标资源应用在语义之上，一个 URI 引用（章节2.7）通常用于表示“目标资源”，用户代理处理它的绝对形式为了获取“目标 URI”。目标 URI 排除了引用的 fragment 组件，如果存在，因为 fragment 标识符表示保留客户端处理（[RFC3986]，章节3.5）。

### 5.2 连接入站

如果一个目标 URI 决定了，一个客户端需要决定一个网路哦请求是否需要去完成期望的语义，如果这样，请求需要指向到哪里。
 
如果客户端有一个缓存[RFC7234]并且请求可以被它满足，则请求通常首先指向到它。

如果请求没有被缓存满足，则一个常见的客户端将会检查它的配置去决定使用哪一个代理去满足请求，代理配置依赖于实现，但是一般基于 URI 前缀命中，选择认证命中，或者全部，代理本身通常通过”http“或者”https“ URI 表示。如果代理是可接受的，客户端链接入站通过建立（或者重用）一个到代理的连接。

如果没有可用的代理，一个典型的客户端将会唤起一个处理器例程，通常针对目标 URI 的方案，去直接连接一个目标资源的认证。这如何完成依赖于目标 URI 方案，定义在它关联的规格，如同这个规格定义的源服务端访问解决方案“http”（章节 2.7.1）和“https”（章节 2.7.2）方案。

HTTP 连接管理的需求定义在章节6。

### 5.3 请求目标

一旦获取到一个入站连接，客户端发送一个 HTTP 请求消息（章节3），携带一个请求目标，源于目标 URI。有4中不同的请求目标格式，依赖于请求的方法和是否请求的是一个代理。
```
    request-target  = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form
```

### 5.3.1 来源格式

请求目标最普通的格式是来源格式
```
    origin-form = absolute-path [ "?" query ]
```
当创建一个请求直接到一个源服务器，不是一个 CONNECT 或者服务器范围的 OPTIONS 请求（就像下面详细说明的），一个客户端必须只发送目标 URI 的绝对路径和查询组件作为请求目标。如果目标 URI 的路径组件是空的，客户端必须发送“/”作为请求目标的 origin-form 的路径。一个 Host 头部域也发送了，就像定义在章节 5.4。

比如，一个客户端希望去获取资源表示的表示，就像
```
    http://www.example.org/where?q=now
```
直接来自源服务端将会打开（或者重用）一个 TCP 连接到“www.example.org”的端口 80 并发送以下行：
```
    GET /where?q=now HTTP/1.1
    Host: www.example.org
```
后面跟随着剩余的请求消息。


### 5.3.2 绝对格式

当创建一个请求到一个代理，不是一个 CONNECT 或者服务端范围的 OPTIONS 请求（就像下面详细描述的），一个客户端必须发送以 absolete-form 形式发送目标 URI 作为请求目标
```
    absolete-form   = absolete-URI
```
被请求的代理是来自有效缓存的请求的服务，如果可能，或者创建和客户端直接请求下一个入站代理服务或者直接到请求目标指定的源服务器的请求一样的请求。对于这类消息“转发”的需求定义在章节 5.7。

一个请求行 absolete-form 格式的栗子：
```
    GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
```
在一些未来版本的 HTTP，为了允许将所有请求转化到 absolute-from，一个服务端必须接受 absolete-form 在请求中，尽管 HTTP/1.1 客户端将只发送他们的请求到代理。

### 5.3.3 认证格式

请求目标的 authority-form 只用于 CONNECT 请求（[RFC7231]的章节4。3.6）。
```
    authority-from  = authority
```
当创建一个 CONNECT 请求去建立一个隧道，通过一个或者多个代理，一个客户端必须发送目标 URI 的认证组件（排除任何用户信息和“@”定界符）作为请求目标。比如，
```
    CONNECT www.example.com:80 HTTP/1.1
```

### 5.3.4 通配格式

请求目标的 asterisk-from 只用于服务端范围的 OPTIONS 请求（[RFC7231]的章节 4.3.7）。
```
    asterisk-form   = "*"
```
当一个客户端希望为整个服务器请求 OPTIONS，而不是特定命名的资源时，客户端必须只发送“*”（%x2A）作为请求目标。比如，
```
    OPTIONS * HTTP/11.1
```
如果一个代理接收到一个 OPTIONS 请求，他的请求目标是 absolute-form，它的 URI 的路径是空的，并且没有查询组件，则请求链最后的代理必须发送一个“*”作为请求目标，当他转发请求到指定的源服务器的时候。
比如，对于请求
```
    OPTIONS http://www.example.org:8001 HTTP:1.1
```
将被最后的代理这么转发
```
    OPTIONS * HTTP/1.1
    Host: www.example.org:8001
```
在连接到主机“www.example.org”端口 8001 之后
### 5.4 主机
请求中的“Host”头部域从目标 URI 提供了主机和端口信息，让源服务器可以区分资源，当在一个 IP 地址为多个主机名服务请求。
```
    Host = uri-host [ ":" port ] ; 章节 2.7.1
```
一个客户端必须发送一个 Host 头部域在所有的 HTTP/1.1 请求信息。如果目标 URI 包含认证组件，则一个客户端必须发送一个 Host 域值表示认证组件，除了任何用户信息子组件和它的“@”界定符（章节 2.7.1）。如果认证组件不存在或者目标 URI 没有定义它，则一个客户端必须发送 Host 头部域，带一个空的域值。

因为 Host 域值是处理一个请求的标准信息，一个用户代理应该生成 Host 作为第一个头部域，跟随在请求行之后：

比如，一个 GET 请求到源服务端 <http://www.example.org/pub/WWW/> 可能开始于：
```
    GET /pub/WWW/ HTTP/1.1
    Host: www.example.org
```
一个客户端必须发送一个 Host 头部域在 HTTP/1.1 请求，就算请求目标是 absolute-form，因为这允许 Host 信息被远古的没有实现 Host 的 HTTP/1.0 代理转发。、

当一个代理接收到一个绝对形式的请求目标的请求的时候，代理必须忽略接受到的 Host 头部域（如果有）并使用请求目标的主机信息替代他。一个代理转发这类的请求必须生成一个新的 Host 域值基于接收到的请求目标，而不是转发接受到的 Host 域值。

因为 Host 头部域表现的像一个应用级路由机制，它是恶意软件寻找的常见目标，用来污染共享缓存或者重定向一个请求到非意图的服务。一个窃听代理特别危险，如果他依赖 Host 域值去重定向请求到内部服务，或者作为共享缓存的缓存 key，没有第一次验证，窃听连接为这个主机指向一个有效的 IP 地址。

一个服务端必须响应一个 400（Bad Request）状态码到任何 HTTP/1.1 请求信息给缺少 Host 头部域和任何请求消息包含多于一个 Host 头部域或者 Host 头部域是一个不合法的域值的时候。


### 5.5 有效的请求 URI

因为请求目标经常包含只有一部分的用代理的目标 URI，一个服务端重构预定目标作为“有效请求 URI”，为了适当的服务请求。这个重构调用服务端的本地配置和请求目标传达的信息，主机头部域和连接上下文。

对于一个用户代理，有效的请求 URI 是目标 URI。

如果请求目标是 absolute-fomr，有效请求 URI 和请求目标相同。否则，有效请求 URI 如下构造：

如果服务端的配置（或者出站网关）提供一个固定的 URI 方案，则方案用于有效请求 URI。否则，如果请求通过 TSL-secured TCP 连接获取，有效请求 URI 的方案是“https”；如果不，方案是“http”。

如果服务端的配置（或者出站网关）提供一个固定的 URI 认证组件，则请求目标用于有效请求 URI。如果不，如果请求目标是 authority-form，哟小请求 URI 的认证组件和请求目标相同。如果不，则如果一个 Host 头部域应用一个非空的域值，认证组件和 Host 的域值相同。否则，认证组件指定为服务端配置的默认名字，如果连接来自 TCP 端口数和有效请求 URI 方案的的默认端口不同，则一个冒号（“:”）和进来的端口数量（以数字格式）拼接到认证组件。

如果请求目标是 authority-form 或者 asterisk-form，有效请求 URI 的组合路径和查询组件是空的。否则，组合路径和查询组件和请求目标相同。

有效请求 URI 的组件，一旦像前面一样被决定，可以合并到 absolute-URI 格式通过拼接方案，“://”，认证，并合并路径和查询组件。

栗子1：下面的信息通过不安全的 TCP 连接接收：
```
    GET /pub/WWW/Theproject.html HTTP/1.1
    Host: www.example.org:8080
```
有一个有效的请求URI：
```
    http://www.example.org:8080/pub/WWW/TheProject.html
```
栗子2：下面的信息通过 TLS 安全的 TCP 连接
```
    OPTIONS * HTTP/1.1
    Host: www.example.org
```
有一个有效的请求 URI：
```
    https://www.example.org
```
HTTP/1.0 请求的接收者缺少 Host 头部域可能需要使用启发式（比如，检测 URI 路径的一些对于特定主机是唯一的）去猜测有效请求 URI 的认证组件。

一旦有效请求 URI 被构造，一个源服务端需要决定是否提供服务，为 URI，通过请求接收到的链接。比如，请求可能错误指定，故意或者意外，接收到的请求目标和 Host 头部域和连接建立的主机或者端口不同的信息。如果连接来自一个可信的网关，可能会出现不一致；否则，他可能表示指定一个尝试绕过安全过滤器，欺骗服务端分发非公共的内容，或者污染一个缓存。查看章节9 关于信息路由的安全注意事项。


### 5.6 关联一个响应到请求

HTTP 没有包含一个请求标识符为关联给定请求消息和它相应的一个或者多个相应信息。因此，它依赖于相应到来的顺序精确对应请求在相同连接创建的顺序。每一个请求有多余一个相应消息只发生在一个或者多个信息相应（1xx，查看[RFC7231]的章节6.2）在相同请求的最后一个相应之前。

一个客户端有多余一个为完成的请求在一个连接必须维护一个委婉曾呢的请求列表，按照请求发送的顺序，必须关联每一个接收到的响应信息到还没接收到最终（非 1xx）响应的最高优先顺序请求。

### 5.7 信息转发
就像章节 2.3 定义的，中介在 HTTP 请求和响应的处理过程中可以服务各种各样角色。一些中介用来提高行呢和可用性。其他用来权限控制或者过滤内容。因此一个 HTTP 流有类似管道和过滤器的架构特点，对于增强（或者插手）流的任何方向没有固定的限制。

一个中介不表现为一个隧道必须实现 Connection 头部域，定义在章节6.1，从转发中排除只用于传入连接的域。

一个中介必须不转发一个消息到他自己，除非他从无限请求循环中被保护。通常，一个中介应该认识他自己的服务名，包含任何昵称，本地变化，或者 IP 地址字面量，并为这些请求直接响应。

### 5.7.1 Via
“Via”头部域只是中介协议的存在和用户代理和服务之间的接收者（在请求上），或者源服务端和客户端之间（在响应中），类似 email 中的“Received”头部域名（[RFC5322]的章节3.6.7）.Via 可以用于跟踪信息转发，避免请求循环，并表示请求/响应链中发送者的协议能力。
```
    Via                 = 1#( received-protocal RWS receive-by [ RWS comment ] )
    received-protocol   = [ protocol-name "/" ] protocol-version
                        ; 查看章节 6.7
    received-by         = ( uri-host [ ":" port ] ) / pseudonym

    pseudonym           = token
```

多个 Via 域值表示每个转发消息的代理或者网关。每一个中介拼接他自己的关于消息如何接收的信息，比如最后的结果是按照转发接收者的序列排序的。

一个代理必须发送适当的 Via 头部域，就像下面描述的，在每一个他转发的消息。一个 HTTP-to-HTTP 网关必须发送一个适当的 Via 头部域在每个入站请求消息，并可能发送一个 Via 头部域在转发的响应消息。

对于每个中介，接收到的协议指示协议和协议版本，用于消息的上行发送者。因此，Via 域值记录请求/响应链公布的协议能力，这样他们对他们下游的接收者可见；这对于向后不兼容的功能可能安全的在响应中使用，或者在之后的请求，描述在章节 2.6。为了简介，协议名可以在接收协议是 HTTP 的时候缺省。

域值接收部分通常是接收服务端的主机和可选的一个端口数或者转发消息的客户端子序列。然而，如果真实的主机被认为是敏感信息，一个发送者可能使用家名替代。如果端口没有提供，一个接收者可能解释为意味着他在默认的的 TCP 端口上接收，如果存在，对于接收到的协议。

一个接收者可能在 Via 头部域生成评论，去标识每一个接收者的软件，类似 User-Agent 和 Server 头部域。然而，Via 域中所有的评论都是可选的，并且一个接收者可能移除他们在转发消息之前。

比如，一个请求消息可以从 HTTP/1.0 用户代理发送到一个内部代理编码名为“fred”，使用 HTTP/1.1 去转发请求到一个在 p.example.net 公共代理，通过转发它到 www.example.com 的源服务器完成请求。被 www.example.com 接收的请求将会有下面 Via 头部域
```
    Via : 1.0 fred, 1.1 p.example.net
```

一个中介作为一个门户穿过一个网络防火墙应该不转发防火墙域的名字和端口，除非它明确的启用他。如果未启用，这样一个中介应该替换每一个接收到的任何在防火墙之后的主机为这个主机合适的假名。

一个中介可能合并一个有序的头部域值完整子序列到一个单独的实体，如果实体有表示的接收的协议值。比如，
```
    Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
```
可以折叠为
```
    Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

一个发送者应该不合并多个条目，除非他们在相同的组织控制之下，并且主机已经用假名替换。一个发送者必须不合并有不同接收协议值的条目。

### 5.7.2 转发

一些中介包含转化消息和他们的负载的功能。一个代理可能，比如，转化图像格式，为了节约缓存空姐或者降低慢连接的交通。然而，操作问题可能出现在当转化应用在负载目标是标准应用的时候，比如医学图像或者科学数据分析，特别当完整性检查或者数字签名被使用去确保接收到的负载和原始一致的时候。


一个 HTTP 到 HTTP 的代理被叫做“转化代理”，如果他设计为或者配置为去修改消息，在语法含义的方式（比如，修改，超出普通 HTTP 处理需求，以对原始发送者有意义或者对下游接收这有潜在意义的方式去改变消息）。比如，一个转化代理可能表现的像共享声明服务（修改响应包含本地声明数据库的引用），一个邪恶软件过滤器，一个格式转码器，或者一个私有过滤器。这类转化界定是客户端（或者客户端组织）选择的代理期望的。

如果一个代理接收到的请求的请求目标的主机名不是完全合格的域名，他可能在转发请求的时候添加自己的域名到接收到的主机名。一个代理必须不修改主机名，如果请求目标包含完全合格的域名。


一个代理在转化它到下一个入站服务端的时候必须不修改接收到的请求目标的“绝对路径”和“查询”部分，除非像上面记录的去替换空的路径为“/”或者“*”。

一个代理可能通过应用或者移除转发编码修改消息体（章节 4）。

一个代理必须不转化一个包含 no-transform cache-control 指令（[RFC7234]的章节 5.2）的消息的负载（[RFC7231]的章节 3.3）。

一个代理可能转化一个不包含 no-transform cache-control 指令的消息的负载。一个代理转化一个负载必须添加一个 Warning 头部域，使用 214（"Transformation Applied"） 警告码，如果没有存在在消息中（查阅[RFC7234]的章节5.5）。一个代理转化一个200（OK）响应的负载可以通过改变响应的状态码为203（Non-Authoritative Infomation）来同志下游接收者一个转化被应用（[RFC7231]的章节6.3.4）。

一个代理应该不修改会话链中提供终端信息的头部域，响应状态或则会选择的代表（除了负载），除非域的定义特别允许修改或者为了隐私和安全，修改被认为是必须的。

### 6. 链接管理

HTTP 消息独立于底层传输或者会话层连接协议。HTTP 只假设一个可信赖的传输，按需分发请求和对应的按需分发响应，HTTP 请求和响应的映射结构到底层传输协议的数据单元在这个规格范围之外。

就像在章节 5.2 描述的，用于 HTTP 交互的具体连接协议是客户端配置和目标 URI 决定的。比如，“http”URI 方案（章节 2.7.1）指定一个基于 IP 的 TCP 默认连接，它的默认 TCP 端口是 80，但是客户端可能配置使用代理通过一些其他连接，端口，或者协议。

HTTP 实现被期待去参与连接管理，包含维护当前连接的状态，建立一个新的连接或者重用一个一存在的连接，处理连接上接收的消息，决定连接失败，关闭每一个连接。大部分客户端同步维护多个连接，每一个服务终端包含多余一个连接。大部分服务端设计维护上线同步连接，当控制请求队列去合理使用和检测拒绝服务攻击。

### 6.1 连接
“Connection”头部域允许发送者为当前连接指定期待的控制选项。为了避免迷惑下游接收者，一个代理或者网关在转发消息之前必须移除或者替换接收到的任何连接选项。

当一个头部域除了 Connection 用来为当前连接提供控制信息，发送者必须在 Connection 头部域列出相应的域名。一个代理或者网关必须在转发一个消息之前转化接收到的 Connection 头部域，并且对于域内的每一个连接选项，从消息内移除任何和连接选项名字相同的头部域，然后移除 Connection 头部域自身（或者使用中介自己的连接选项替换它）。

因此，Connection 头部域提供了一个声明式的区分只用作立即接收者（逐跳）和用于链中所有接收者（端到端），允许消息自我描述，并允许未来连接指定扩展可以部署，不需要但系他们会被老得中介盲转发。

Connection 头部域的值有下列的语法：
```
    Connection          = 1#connection-option
    connection-option   = token
```

连接选项是大小写不敏感的。

一个发送者必须不发送一个表示一个用于所有接收者的负载的头部域的链接选项。比如，Cache-Control 永远不适合作为一个连接选项（[RFC7234]的章节5.2）。

连接选项不总是和存在在消息中的头部与相符，因为一个连接指定头部域可能不需要，如果连接选项没有关联的参数。相反的，一个接收到的连接指定的头部域没有相符的连接选项通常指示这个域不适当的被一个中介转发，应该被接收者忽略。

当定义一个新的连接选项，规格作者应该调查存在的头部域名，确保新的连接选项没有和已经部署的头部域分享相同的名字。定义一个新的连接选项本质上保留潜在的域名，用来携带关于连接选项额外的信息，因为在其他任何地方使用这个域名都是愚蠢的。

“close”连接选项定义用来给发送者只是这个连接将会在玩曾呢响应之后关闭。比如：
```
    Connection: close
```

在请求或者响应头部域中指定这个，发送者将会在当前请求/响应完成的时候关闭这个连接（章节6.6）。


一个不支持持久化连接的客户端必须在每一个请求消息中发送“close”连接选项。

一个不支持持久化连接的服务端必须在每一个不是 1xx（Informational）的响应消息中发送“close”连接选项，

### 6.2 建立

连接如何通过一系列传输或者会话层协议建立连接超出了这个规格的描述范围。

### 6.3 持久化

HTTP/1.1 默认使用“持久化连接”，允许多请求和响应在一个单独的连接上运输。“close”连接选项用来指示一个连接在当前的请求/响应之后将不再持久。HTTP 实现应该支持持久化连接。

一个接收者决定一个连接是否持久或者不，基于最新接收到的消息的协议版本和 Connection 头部域名（如果存在）。
- 如果“close”连接选项存在，连接在当前响应知乎将不在持久；否则
- 如果接收到的协议是 HTTP/1.1（或者更新），连接将会在当前响应之后持久；否则
- 如果接收到的协议是 HTTP/1.0，“keep-alive”连接选项存在，接收者不是一个代理，并且接收者希望遵守 HTTP/1.0 “keep-alive”机制，连接将会在当前响应之后持久化；否则
- 连接将会在当前响应之后关闭

一个客户端可能在持久化连接发送额外的请求直到他发送或者接收一个“close”连接选项或者接收一个 HTTP/1.0 响应没有“keep-alive”连接选项。

为了维护持久化，连接上所有的消息需要有自定义的消息长度（比如，一个没有通过连接关闭定义），描述在章节3.3。一个服务端必须读取整个请求消息政委或者在发送响应后关闭连接，因为其他在持久化连接中的剩余的数据将会被误解释为下一个请求。同样的，一个客户端必须读取这个那个响应消息正文如果他想要为接下来的序列的请求重用相同的连接。

一个代理服务端必须不和一个 HTTP/1.0 维护一个持久化连接（查阅[RFC2068]的章节19.7.1，了解关于许多 HTTP/1.0 客户端实现 Keep-Alive 头部域问题的更多信息和讨论）。

查看附录 A.1.2 了解更多向后兼容 HTTP/1.0 客户端的信息。

### 6.3.1 重试请求

连接可能在任何时候被关闭，带或者不带意图。实现应该预料到从异步关闭事件恢复的需求。

当一个入站连接过早的关闭，一个客户端可能打开一个新的连接，自动重试一个放弃的序列的请求，如果所有的这些请求有幂等方法（[RFC7231] 章节4.2.2）。一个代理必须不自动重试非幂等请求。

一个用户代理必须不自动重试非幂等方法的请求，除非他有办法知道请求语义是真正的幂等，无视方法，或者一些方法去检测原始请求从未被接受。比如，一个用户代理知道（通过设计或者配置）一个 POST 请求一个指定资源是安全的可以重复，则自动请求。同样的，一个用户代理特别设计去操作一个版本控制仓库可以用来从部分失败条件中恢复，通过检查目标资源在失败连接之后的修改，恢复或者修改任何部分接受的改变，然后自动重试失败的请求。

一个客户端应该不自动重试失败的自动重试。

### 6.3.2 管道

一个支持持久化连接的客户端可能“管道”它的请求（比如，发送多个请求不等待每一个响应）。一个服务端可能同步处理一个序列的管道请求，如果他们有相同的安全方法（[RFC7231]的 4.2.1 章节），但是必须以接收到的请求相同的顺序发送相应的响应。

一个管道请求的客户端应该重试没有应答的响应，如果连接在接收到所有响应的响应之前关闭。当在失败连接之后尝试重试管道化请求（一个连接没有明确的被服务端关闭，在他完成最后一个响应），一个客户端必须不在连接连理的时候立马管道化。因为第一个第一个维护的请求在前面的管道可能导致一个错误响应，如果多个请求发送在一个过早的关闭的连接可能再一次丢失（查看描述在章节 6.6 TCP 重置问题）。

幂等方法（[RFC7231]章节 4.2.2）对于管道化是很重要的，因为他们可以自动在一个连接失败之后重试。一个用户代理应该不管道化一个非幂等性方法请求，直到接收到最后的响应状态码，除非用户代理有方法知道检测和恢复部分失败的管道化序列的条件。

一个接受管道化请求的中介可能在转发他们入站的时候管道化这些请求，因为这依赖于出站用户代理去决定什么请求可以安全的管道化。如果入站连接在接收到响应前失败，管道化的中介可能尝试重试一个序列已经接收到的响应如果请求都有幂等性方法的请求；否则，管道化中介应该转发和任何接收到的响应，然后关闭对应的出站连接，这样出站用户代理可以据此恢复。

### 6.4 并发

一个客户端应该限制与给定服务器维护的同步打开的连接的数量。

前面版本的 HTTP 给定一个明确的数量的连接作为一个天花板，但是最后发现这对于很多应用是不适用的。作为结果，这个规格没有搜全一个特定的连接最大数量，但是，作为替代，鼓励客户端谨慎打开多个连接。

多连接通常用于避免“队头堵塞”问题，一个请求需要重大服务端处理和/或有大块子序列请求在相同连接。然而，每一个连接消耗服务端资源。而且，适用多连接导致不期望的副作用在拥挤网络。

注意一个服务端可能拒绝流量，他认为是拒绝服务攻击的特征，比如从一个客户端打开过多数量的连接。

### 6.5 失败和超时

服务端通常有一些超时值，超出这个事件，他们将不会再维护一个不活跃的连接。代理服务端可能让这个值更大一些，因为客户端可能创建更多通过相同代理服务的连接。持久化连接对客户端或者服务端的超时长度（或者存在）有需求。

一个客户端或者服务端希望去超时应该在连接上发起一个优雅的关闭。实现应该不断的监听打开的连接，直到收到一个关闭信号，并适当的响应，因为适当的关闭连接的两端让分配的系统资源被回收。

一个客户端，服务端，或者代理可能在任何事件关闭传输连接。比如，一个客户端可能开始发送一个新的请求，同时服务端决定关闭“空闲”连接。从服务端的观点来看，连接在它空间的时候关闭，但是从客户端的观点来看，一个请求正在进行中。

一个服务端应该维护持久化连接，当可能的时候，允许底层传输的流量控制机制去解决暂时超载，而不是终止连接期待客户端重试。后者的技术会恶化网络拥堵。

一个客户端发送消息正文应该监控网络连接，直到一个错误响应，当他传输请求的时候。如果客户端砍价一个响应指示服务端不希望接受消息正文并且正在关闭连接，客户端应该立即终止正在传输的正文并关闭这一边的连接。


### 6.6 断开

Connection 头部域（章节 6.1）提供一个“close”连接选项，当发送者应该在它希望在当前请求/响应对之后关闭连接的时候发送这个连接选项。

一个客户端发送“close”连接选项必须不在这个连接上发送更多请求（在发送包含“close”的那个连接之后）并且必须在读取请求对应的最后的响应消息后关闭连接。

一个服务端发送一个”close“连接选项必须初始化一个连接关闭，在发送包含”close“的响应之后。服务端必须不处理任何更多连接上接收到的请求。

一个客户端接收到一个“close”连接选项必须停止在这个连接上发送请求，并在读取包含“close”响应消息之后关闭连接；如果额外的管道请求在连接上发送，如果客户端应该不假设他们会被服务端处理。


如果一个服务端执行一个立即关闭 TCP 连接，客户端可能无法读取最后的 HTTP 请求，这是一个很重要的风险。如果服务端在一个完全关闭的连接上接受了额外的数据，比如其他客户端发送的请求，在接收到服务端的响应之前，服务端 TCP 栈将会发送一个重置包可能清除客户端的不被承认的输入缓存，在他们可以被客户端的 HTTP 解析器读取和解释之前。

为了避免 TCP 重置问题，服务端通常分阶段关闭连接。首先，服务端执行一个半关闭，通过关闭读/写连接的写。服务端继续从连接读取，直到从客户端接收到一个响应的关闭，或者直到服务端有原因的确认 TCP 栈接收到客户端的包只是包含服务端最后响应。最后，服务端完全关闭连接。

重置问题是否是 TCP 独有的还是可以在其他传输连接协议找到，这是未知的。

### 6.7 升级

“Upgrade”头部域为在相同连接上转化 HTTP/1.0 为其他协议提供一个简单的机制。一个客户端必须在 Upgrade 头部域中发送一个协议列表，邀请服务端切换到这些协议中的一个，按优先级降序，在发送最终响应之前。服务端可能忽略接收到的 Upgrade 头部域，如果他希望继续使用当前的协议在这个连接上。Upgrade 不能用于强制协议改变。
```
    Upgrade             = 1#protocol
    protocol            = protocol-name [ "/" protocol-version ]
    protocol-name       = token 
    protocol-version    = token
```
一个服务端发送 101（Switching Protocol）响应必须发送一个 Upgrade 头部域去指定一个新的连接要切换的协议；如果多一个协议层被切换，发送者必须按层升序列出协议。一个服务端必须不切换到一个不在相应的客户端的 Upgrade 头部域指定的协议。一个服务端可能选择去忽略客户端的偏爱，选择新的协议，基于其他因素，比如请求的性质或者服务端当前加载的。

一个服务端发送 426（Upgrade Required）响应必须发送一个 Upgrade 头部去指定可接受的协议，按偏好降序。

一个服务端可能发送一个 Upgrade 头部域在任何响应中，告知他首先支持升级到列表中的协议，按偏好降序，当适合一个未来的请求。

下面是一个客户端发送的栗子：
```
    GET /hello.txt HTTP/1.1
    Host: www.example.com
    Connection: upgrade
    Upgrade: HTTP:2.0, SHTTP/1.3, IRC/6.9, RTA/x11
```

切换协议后应用级的会话的能力和性质完全依赖于新的协议选择。然而，发送 101（Switching Protocol）响应之后，服务端期待继续响应原始的请求，就像他已经接收到他相同的新协议（比如，服务端依旧还有挂起的请求去满足，在协议改变之后，并且期待去这么走而不需要重新发送请求）。


比如，如果 Upgrade 头部域在一个 GET 请求接受到，服务端决定切换协议，它的第一个HTTP/1.1 101（Switching Protocols）响应消息，然后立马跟着目标资源上一个 GET 响应相同的新协议。这允许连接使用 HTTP 相同的语义升级协议，不需要额外的往返等待时间消耗。一个服务端必须不切换协议，除非接收到的消息语义可以被新协议遵循；一个 OPTIONS 请求可以被任何协议遵循。

下面的栗子是上面的假设的请求的响应：
```
    HTTP/1.1 101 Switching Protocols
    Connection: upgrade
    Upgrade: HTTP/2.0
    [...数据流切换到 HTTP/2.0，使用一个适当的响应（定义在新协议）给“GET /hello.txt”请求...]
```

当 Upgrade 被发送，发送者必须发送一个 Connection 头部域（章节 6.1），包含一个“upgrade”连接选项，为了防止 Upgrade 被没有实现列出协议的中介意外转发。一个服务端必须忽略一个从 HTTP/1.0 请求接收到的 Upgrade 头部域。

一个客户端不能在一个连接上开始使用一个升级的协议，直到它完成发送请求消息（比如，客户端不能在消息中间改变协议）。如果服务端同时接收到 Upgrade 和一个 Expect 头部域，和“101-continue”异常（[RFC7231]的章节 5.1.1），服务端必须发送一个100（Continue）响应在发送101（Switching Protocols）响应之前。

Upgrade 头部域值应用于切换协议，在存在的连接之上；他不能用来切换底层连接（传输）协议，或者切换存在的会话到一个不同的连接。为了这些目的，更适合使用 3xx（Redirection）响应（[RFC7231]的章节 6.4）。

这个规格只定义了协议名“HTTP”，被超文本传输协议家族使用，被章节 2.6 的 HTTP 版本规则定义，然后升级到这个规格。额外的令牌应该在 IANA 注册，使用定义在 章节8.6 的注册产生式注册到 IANA。


### 7. ABNF 列表扩展：#rule

一个 [RFC5234]的 ABNF #rule 扩展用来提高一些头部域值的定义的可读性。

定义一个“#”构造器，类似“*”，是为了逗号界定的列表元素。完整的格式是“<n>#<m>element”指示至少 <n> 和最多 <m> 个元素。每一个使用单独的逗号（“,”）和可选的空格（OWS）。

在任何使用列表结构的产生式中，一个发送者必须不生成空的列表元素。换句话说，一个发送者必须生成满足下列语法的列表：
```
    1#element => element *( PWS "," OWS element )
```
和：
```
    #element => [ 1#element ]
```
和 n >= 1 和 m > 1：
```
    <n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )
```
为了兼容旧的列表规则，一个接收者必须转化和忽略合理数量的空列表元素：足够处理合并值的发送者的常见错误，但是不足以用来称为拒绝服务的机制。换句话说，一个接收者必须接受一个满足下列语法的列表：
```
    #element => [ ( "," / element ) *( OWS "," [ OWS element ] ) ]
    1#element => *( "," OWS element *( OWS "," [ OWS element ] ) )
```

空元素对原属的数量没有贡献，给定这些 ABNF 生产时：
```

    example-list        = 1#example-list-elmt
    example-list-elmt   = token ; 查看 章节 3.2.6
```
则下面是 example-list 有效的值（不包括双引号，只是表示界定）：
```
    "foo,bar"
    "foo ,bar"
    "foo , ,bar,charlie"
```

相反，下面的值是不合法的，因为 example-list 产生式需要至少一个非空元素：
```
    ""
    ","
    ",   ,"
```
附录 B 显示接收者 ABNF 在扩展列表结构之后的集合。

### 8. IANA 考虑
### 8.1 头部域注册
### 8.2 URI 方案注册
### 8.3 互联网媒体类型注册
### 8.3.1 互联网媒体类型信息/http
### 8.3.2 互联网媒体类型应用/http
### 8.4 传输编码注册
### 8.4.1 程序
### 8.4.2 注册
### 8.5 内容编码注册
### 8.6 升级令牌注册
### 8.6.1 程序
### 8.6.2 升级令牌注册

### 9. 安全考虑
### 9.1 建立认证
### 9.2 中间人风险
### 9.3 通过协议元素长度攻击
### 9.4 响应分割
### 9.5 请求走私
### 9.6 消息完整性
### 9.7 消息机密性
### 9.8 服务器日志信息私密


### 10. 致谢


### 11. 引用
### 11.1 规范引用
### 11.2 信息引用

### 附录A：HTTP 版本历史
### A.1 从 HTTP/1.0 后的改变
### A.1.1 多宿主网页服务
### A.1.2 持久连接
### A.1.3 传输编码介绍
### A.2 从 RFC 2616 后的改变

### 附录B：ABNF 集合