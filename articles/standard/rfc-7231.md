### RFC 7231 Semantic and Content

### 备忘录状态

### 版权注意

### 1. 介绍

每一个超文本传输协议（HTTP）信息要么是一个请求，要么是一个响应。一个服务端在在一个连接上监听请求，转化每一个接收到的消息，解释和表示请求目标相关的消息语义，并使用一个或者多个响应消息响应请求。一个客户端构造请求消息去传达特定意图，检查接受到的响应意图是否被执行，并决定如何解释结果。这个文档使用 \[RFC7230\] 定义的术语定义了 HTTP/1.1 请求和响应语义。

HTTP 提供了一个和资源（章节 2）交互的通用接口，无视它的类型，性质，或者实现，通过操作和传输表现（章节 3）。

HTTP 语义包括每一个请求方法定义的意图（章节 4），这些语义的扩展可能描述在请求头部域（章节 5），状态码指定的机器可读响应的意义（章节 6），和其他阿控制数据和资源元数据的意义可能在响应头部域给出（章节 7）。

这文文档也定义了表现元数据，描述了一个负载期待如何被接收者处理，请求头部域可能影响内容选择，一系列选择算法集合引用为“内容协商”（章节 3.4）。

### 1.1 一致性和错误错误

### 1.2 语法符号

### 2. 资源

HTTP 请求的目标叫做“资源”。HTTP 不限制资源的性质；他仅仅定义了一个可能用来和资源交互接口。每一个资源使用统一资源标识符（URI），定义在 \[RFC7230\] 的章节 2.7。

当客户端构造一个 HTTP/1.1 请求消息，它使用各种格式中的一种发送目标 URI，定义在（\[RFC7231\] 的章节 5.3）。当接收到一个请求，服务端为目标资源重新构建一个有效请求 URI。

HTTP 的其中一个设计目标是从请求语义中分离资源资源表示，通过请求方法（章节 4）的请求语义和少量请求修改头部域（章节 5）可以实现。如果方法语义和 URI 自身暗示的语义冲突了，定义在章节 4.2.1，方法语义优先。

### 3. 表现

考虑到一个资源可以是任何东西，并且 HTTP 提供的通用接口类似一个窗口，通过它可以观察和处理这类东西，只能通过另一端独立的参与者交流信息，一个抽象需要表示（“代替”）当前或者期望的状态，在我们的交流中的这个东西。这个抽象叫做表现 \[REST\]。

因为 HTTP 的目的，一个“表现”是一个反映给定资源过去，当前，或者期望的状态的信息，以通过协议可信通行的格式，它由一些列表现元数据和一个潜在的无限的表现数据。

一个源服务端可能提供，或者可以被生成，多个表现，每一个用于反映目标资源的当前状态。在这类场景中，一些算法被源服务器用来选择其中的一个表现，最适用于给定请求，通常基于内容协商。这个“选择的表现”用来为评估条件请求 \[RFC7232\] 和构造 200（OK）和 304（Not Modified）GEt 响应负载提供数据和元数据。

### 3.1 表现元数据

表现头部域提供表现相关的元数据。当消息包含负载体，表现头部域描述如何解释负载体内的表现数据。在 HEAD 请求的响应中，表现头部域描述如果相同的请求是 GET，已经封闭在负载体内的表现数据。

下面的头部域覆盖了表现元数据：

| 头部域名 | 定义在 |
| --- | --- |
| Content-Type | 章节 3.1.1.5 |
| Content-Encoding | 章节 3.1.2.2 |
| Content-Language | 章节 3.1.3.2 |
| Content-Location | 章节 3.1.4.2 |

### 3.1.1 处理表现数据

### 3.1.1.1 媒体类型

HTTP 在 Content-Type（章节 3.1.1.5）和 Accept（章节 5.3.2）头部域使用互联网媒体类型 \[RFC2046\]，为了提供开放和可扩展的数据类型和内容协商。媒体类型定义了一个数据格式和一系列的处理模型：怎样处理数据根据接收它的每一个上下文。

```
    media-type  = type "/" subtype * ( OWS ";" OWS parameter )
    type        = token
    subtype     = token
```

type/subtype 后面可能跟着 name=value 对格式的参数。

```
    parameter   = token "=" ( token / quoted-string )
```

type， subtype，和参数名令牌是大小写不敏感的，参数值可能或者可能不是大小写敏感，依赖于参数名的语义。参数的存在或者不存在对于媒体类型的处理可能非常重要，依赖于他在媒体类型注册的定义。

一个参数值匹配令牌产生式可以被传输为一个令牌或者在引用字符串内。引用或者不引用的值都是相等的。比如下面的栗子全是相同的，但是第一个是一致性首选。

```
    text/html;charset=utf-8
    text/html;charset=UTF-8
    text/html;charset="utf-8"
    text/html; charset="utf-8"
```

互联网媒体类型可能定义在 IANA，基于定义在 \[BCP13\] 的产生式。

注意：不像其他头部域的构建方式，媒体类型参数不允许在“=”字符周围有空格（甚至是“坏的”空白）。

### 3.1.1.2 字符集

HTTP 使用字符集名称去指定或者协商一个文字表现的字符编码方案 \[RFC6365\]。一个字符集使用大小写不敏感的令牌标识

```
    charset = token
```

字符集名字应该被注册在 IANA 的“字符集合”注册（[http://www.iana.org/assignments/character-sets](http://www.iana.org/assignments/character-sets)），基于定义在 \[RFC2978\] 的产生式。

### 3.1.1.3 规范化和默认文本

互联网媒体类型使用规范化的格式注册，为了在多种本地编码格式的系统中互相操作。通过 HTTP 选择或者传输的表现应该以规范化的格式，由于许多相同的原因，描述在多目的互联网邮件扩展（MIME）\[RFC2045\]。然而，邮件部署的性能特性和 普通的 HTTP 和 Web（基于服务的信息服务） 有非常大的不同。甚至，MIME为了兼容旧的邮件传输协议，限制在 HTTP MIME 的规范化格式中不允许应用 CRLF 作为“text”媒体子类型的文字断行。HTTP 允许使用纯 CR 或者 LF 表示换行符的文本媒体的传输，当这类换行符对于整个表现是一致的时候。一个 HTTP 发送者可能生成，一个接收者必须可以转化，文本媒体中的换行符，包括 CRLF，仅 CR， 或者仅 LF。此外，HTTP 的文本媒体不限制各自使用 13 和 10 八位位组的字符集来表示 CR 和 LF。这个灵活性无视换行符，只应用在表现被赋予“text”媒体类型的时候；它不应用于“multipart”类型后者在负载正文之外的 HTTP 元素（比如，头部域）。

如果一个表现使用内容编码编码，底层数据应该以前面的格式被编码。

### 3.1.1.4 多部分类型

MIME 提供了一些列的“多部分”类型 -- 封装一个或者多个表现到一个单独的消息正文。所有的多部分共享一个相同的语法，定义在  \[RFC2046\] 的章节 5.1.1，包含一个 boundary 参数作为媒体类型值的一部分。消息正文是它自己的一个协议元素；一个发送者必须只生成 CRLF 去表示正文部分的换行符。

HTTP 消息帧不使用多部分边界作为消息正文长度的指示符号，尽管它可能在实现生成或者处理负载的时候用到。比如，“multipart/form-data”类型通常用于在请求内运输数据，定义在 \[RFC2388\]，这个规格定义的 “multipart/byteranges”类型用于一些 206（Partial Content）响应 \[RFC7233\]。

### 3.1.1.5 Content-Type

“Content-TYpe”头部与指示关联的表现的媒体类型：封装在消息负载中的表现或者选择的表现，取决于消息语义。指定的媒体类型定义了数据格式，以及数据希望如何被接收者处理，在接收消息语义的范围内，在 Content-Encoding 指定的编码被解码之后。

```
    Content-Type = media-type
```

媒体类型定义在章节 3.1.1.1。这个域的一个栗子：

```
    Content-Type: text/html; charset=ISO-8859-4
```

一个发送者生成一个包含负载正文的消息应该生成一个 Content-Type 头部域在消息中，除非封装的表现的目标媒体类型对于发送者是未知的。如果 Content-Type 头部域不存在，接收者可能假设一个媒体类型“application/octet-stream”（\[RFC2046\]， 章节 4.5.1） 或者检查数据以确定它的类型。

在实践中，资源的拥有者并不总是会合适的配置他们的源服务器为给定表现提供一个正确的 Content-Type，结果，一些客户端会检查一个负载的内容，然后覆盖指定的类型。客户端这么做可能会得出错误的结论，可能保留额外的安全风险（比如，权限升级）。甚至，检查数据格式无法决定发送者的意图：很多数据格式匹配多种媒体类型，他们的区别只有语义。鼓励实现提供一个禁用此类“内容嗅探”的手段。

### 3.1.2 为了压缩或者简洁的编码

### 3.1.2.1 内容编码

内容编码值指定一个已经应用或者可以应用到一个表现的编码转化。内容编码主要用于允许一个表现去压缩或者其他有用转化而不丢失信息。通常，表现存储在编码格式，直接运输，然后在最红接收者那解码。

```
    content-coding  = token
```

所有的内容编码值是大小写不敏感的，应该在“HTTP 内容编码注册”中注册，定义在章节 8.4。他们用在 Accept-Encoding（章节 5.3.4）和 Content-Encoding（章节 3.1.2.2）头部域。

下列是这个规格定义的内容编码值：

```
    compress（和 x-compress）：查看 [RFC7230] 的章节 4.2.1
    deflate：查看 [RFC7230] 的章节 4.2.2
    gzip（和 x-gzip）：查看 [RFC7230] 的章节 4.2.3
```

### 3.1.2.2 内容编码

“Content-Encoding”头部域指示应用什么内容编码到表现，在媒体类型固有之上，和什么解码机制应该被应用于去获取 Content-Type 头部域指定的媒体类型的数据。Content-Encoding 主要用于允许压缩表现的数据而不丢失底层媒体类型的标识。

```
    Content-Encoding    = 1#content-coding
```

一个它使用的栗子：

```
    Content-Encoding: gzip
```

如果一个或者多个编码被应用于表现，应用编码的发送者必须生成 Content-Encoding 头部域，并按顺序列出应用的编码。额外关于编码参数的信息可以通过其他不在这个规格定义的头部域提供。

不像 Transfer-Encoding（\[RFC7230\] 的章节 3.3.1），Content-Encoding 中列出的编码是表现的特征；表现定义为编码格式，所有其他表现的元数据是关于编码形式的，除非标志是元数据定义。通常，表现通常在渲染或者类似使用之前才解码。

如果媒体类型包含一个固有的编码，比如一个数据格式总是被压缩的，那么这个编码不能在 Content-Encoding 中被重申，就算他和其中一个内容编码的算法一致。这样一个内容编码只能被列出，因为一些奇怪的原因，它被第二次应用于组织表现。同样的，服务端可能选择去发布相同的数据，作为多个表现，它们的不同之处仅仅在于编码是否定义为 Content-Type 或者 Content-Encoding 的一部分，因为一些用户代理在每一个响应的处理都不同（比如，打开一个“另存为...”弹唱替代自动解压和渲染内容）。

一个源服务端可能响应一个 405（Unsupported Media Type）状态码，如果一个请求消息中的表现有一个不被接收的内容编码。

### 3.1.3 观众语言

### 3.1.3.1 语言标签

一个语言标签，定义在 \[RFC5646\]，标志一个自然语言，说，写，或者其他覆盖人类和其他人类信息交流。计算机语言明确的排除。

HTTP 在 Accept-Language 和 Content-Language 头部域内使用语言标签。Accept-Language 使用广阔的语言范围产生式，定义在占个鸡 5.3.5，然而，Content-Language 使用定义在下面的语言标签产生式。

```
    language-tag    = <Language-Tag, 查看 [RFC5646] 的章节 2.1>
```

一个语言标签是一个或者多个大小写不敏感的子标签序列，每一个使用横杆字符（“-”，%x2D）分割。在大部分的场景中，一个语言标签由主语言子标签，它标识一个广泛的相关语言家族（比如，“en” = Engilish），后面可选的跟随一个系列的子标签，提炼和收缩语言的范围（比如，“en-CA” = 多样性的英语在加拿大使用）。空格不允许出现在语言标签中。标签栗子包含：

```
    fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

查看 \[RFC5646\] 了解更多信息。

### 3.1.3.2 Content-Language

“Content-Type”头部域名描述了表现的目标观众的自然语言。注意这可能和表现内使用的语言完全一样。

```
    Content-Type    = 1#language-tag
```

定义在章节 3.1.3.1 的语言标签。Content-Language 的主要目的是允许一个用户使用用户自己偏爱的语言去标识和区分表现。因此，如果内容只为了服务一个 Danish-literate guanzh，合适的值是：

```
    Content-Language: da
```

如果没有指定 Content-Language，默认认为内容目标是所有观众。这可能意味着发送者没有考虑到指定它为任何自然语言，或者发送者不知道哪一个语言是目标。

多语言可能为内容列出为了服务多中观众。比如一个“怀唐伊条约”演出，同时以 Maori 和 English 版本，会调用

```
    Content-Language: mi, en
```

然而，只因为一个表现内使用多种语言来表示不意味着用于多语言观众。一个栗子可以是初学者的语言入门，这样一个“A First Lesson in Latin”，很明显用于一个英语语种的观众。在这个场景中，Content-Language 合适的值值包含“en”。

Content-Language 可以应用于任何媒体类型 --  他不局限于文本文档。

### 3.1.4 标识

### 3.1.4.1 识别表现

当一个完整或者部分的表现在消息负载中被传输，通常期望一个发送者去支持，或者接收者去决定，一个标识符用来表示资源相符的表现

对于一个请求消息：

* 如果请求有一个 Content-Location 头部域，则发送者断言负载是一个资源的表现，通过 Content-Location 域值。然而。这样一个断言不能被信任，除非他可以通过其他手段（不在这个规格内定义）。信息可能依旧对修改历史连接有用。
* 否则，负载是不可识别的。

对于一个响应消息，下面的规则依次应用，直到匹配：  
1. 如果请求方式是 GET 或者 HEAD，并且响应状态码是 200（OK），204（No Content），206（Partical Content），或者 304（未定义），负载是资源的表现，通过有效请求 URI（\[RFC7230\] 的章节 5.5）识别。

1. 如果请求方式是 GET 或者 HEAD，并且响应状态码是 203（Non-Authority Infomation），负载是中介提供的目标资源的一个潜在的修改或者增强的表现。

2. 如果响应有一个 Content-Location 头部域，并且它的域值是和有效请求 URI 相同的 URI 引用，则负载是资源的表现，通过有效请求 URI 识别。

3. 如果响应有一个 Content-Location 头部域，并且它的域值是和有效请求 URI 不相同的 URI 引用，则发送者断言这个负载是资源的表现，通过 Content-Location 域值识别。然而，这样一个断言不能被信任，除非可以通过其他手段验证（不在这个规格内定义）

4. 否则，负载是不可识别的。

### 3.1.4.2 Content-Location

“Content-location”头部域引用一个 URI 可以作为一个指定资源的表示，表示消息负载中的表现。换句话说，如果一个 GET 请求在这个 URI 上执行，当这个消息生成的时候，则一个 200（OK）响应将会包含相同的表现封装在消息的负载里。

```
    Content-Location    = absolute-URI / partial-URI
```

Content-Location 值不是有效请求 URI 的替代（\[RFC7230\] 的章节 5.5）。它是表现元数据。它和定义在 \[RFC2557\] 章节 4 的 MIME 正文部分相同名字的头部域有相同的语法和语义。然而，他出现在一个 HTTP 消息对于 HTTP 接收者有一些特殊暗示。

如果 Content-Location 在一个 2xx（Successful）响应消息中，他的值引用一个 URI，和有效请求 URI 相同，则接收者可能认为负载是当前资源的表现，在消始发日期指定的时间。对于一个 GET（章节 4.3.1）或者 HEAD（章节 4.3.2）请求，这和默认语义相同，当服务端没有提供 Content-Location。对于一个状态改变请求，比如 PUT（章节 4.3.4）和 POST（章节 4.3.3），他意味着服务端响应包含这个资源的新表现，因此从表现中区分它值和动作的报告有关（比如，“It worked”）。这允许认证应用去更新他们本地复制，而不需要接下来的 GET 请求。

如果 Content-Location 包含在一个 2xx（Successful）响应消息，并且它的域值引用的 URI 和有效请求 URI 不同，则域服务器声称 URI 是一个不同资源的标识符，和封装的表现相符。这么一个声明只有在标识符分享相同的资源拥有者可信，这无法通过 HTTP 程序化决定。

* 对于一个 GET 或者 HEAD 请求的响应，这是一个有效 URI 引用资源的标识，它是内容协商的主题，Content-Location 域值是选中表现的更特殊的标识。

* 对于一个状态改变方法的 201（Created）响应，Content-Location 域值和 Location 域值相同，负载是新创建资源的当前表现。

* 否则，这么一个 Content-Location 指示这个负载是请求动作的状态报告的表现，并且可以从给定的 URI 得到相同的报告（将来使用 GET 访问）。比如，一个通过一个 POST 请求生成的采购交易可能包含接收到的文档作为 200（OK）响应的负载；Content-Location 域值提供一个在未来获取相同接收的拷贝标识。

一个用户代理在请求消息中发送 Content-Location 标识它的值引用用户代理原始获取封装表现的内容（在被用户代理修改之前）。换句话说，用户代理提供一个返回原始表现资源的链接。

一个源服务器接收到一个包含 Content-Location 域的请求消息必须对待消息类似临时上下文，而不是保存为表现一部分的元数据。一个源服务器可能使用这个上下文去引导处理请求，或者为其他使用保存它，比如，源链接或者版本控制元数据。然而，一个源服务必须不使用这样的上下文信息去修改请求语义。

比如，入股一个客户端创建一个 PUT 请求在一个协商资源，并且源服务接收 PUT（没有重定向），则资源的新状态起期待和应用在 PUT 上的一致；Content-Location 不能用作反向内容选择标识符，去更新唯一的协商表现。如果用户代理想要后一种语义，它将直接应用 PUT 到 Content-Location URI。

### 3.2 表现数据

HTTP 消息关联的表现数据要么作为消息的负载正文提供，或者引用消息语义和有效请求 URI。表现数据以定义在表现元数据头部域编码的形式。

表现数据的数据类型通过头部域 Content-Type 和 Content-Encoding 决定。这定义了两层，排序编码模型：

```
    representation-data := Content-Encoding( Content-Type( bits ) )
```

### 3.3 负载语法

一些 HTTP 消息传输完整或者部分表现作为消息的“负载”。在一些场景中，一个负载可能只包含关联的表现的头部（比如，HEAD 的响应）或者只有表现的部分（比如，206（Partial Content）状态码）。

请求中负载的目标通过方法语义定义。比如，PUT 请求（章节 4.3.4）负载中的表现表示目标资源的期待状态，如果请求被成功应用，然而 POST 请求（章节 4.3.3）负载中的表现表示被目标资源处理的信息。

在响应中，负载的目标是被请求方法和响应状态码定义的。比如，GET（章节 4.3.1）的 200（OK）的负载表示当前目标资源的状态，在消息始发日期（章节 7.1.1.2）观察到的，然而，有相同状态码的 POST 的响应的负载可能表示处理结果或者应用处理之后目标资源的新状态。错误状态码的响应消息通常包含一个负载，表示一个错误条件，他描述错误状态和拓建下一步如何做去处理它。

指定迎来描述负载的头部域，预期说关联表现，更像用作“负载头部域”。负载头部域定义在这个规格的其他部分，因为他们影响消息转化。

| 头部域名字 | 定义在 |
| --- | --- |
| Content-Length | \[RFC7230\]的章节 3.3.2 |
| Content-Range | \[RFC7233\]的章节 4.2 |
| Trailer | \[RFC7230\]的章节 4.4 |
| Transfer-Encoding | \[RFC7230\]的章节 3.3.1 |

### 3.4 内容协商

当响应表达负载信息的时候，只是一个成功或者失败，源服务器通常有不同的方式表示信息；比如，不同的格式，语言，或者编码。同样的，不同的用户或者用户代理可能有不同的能力，字符，或者偏好，可以影响表现，在这些可用的，最好提供。因为这个原因，HTTP 提供内容协商的机制。

这个规格定义了两种模式的内容协商，可以在协议中可见：“主动协商”，服务端基于用户代理的偏好选择表现，“响应”协商，服务端为用户代理提供表现列表以供选择。其他模式的内容协商包括“条件内容”，由多个部分构成的表现选择性的基于用户代理参数渲染，“活跃内容”，表现包含一个脚本创建额外（更加特殊）的请求，基于用户代理的性质，“透明内容协商”（\[RFC2295\]），内容选择是中介执行的。这些模式不是相互排除的，每一个都在实用性和适用性之间权衡。

注意：在所有的场景中，HTTP 没有意识到资源语义。源服务器对请求的响应的一致性，跨越时间和内容协商的尺寸，因此，锁着时间，资源的可观察的表现的“相同性”完全决定于实体或者算法选择，或者生成这些响应。HTTP 不注意幕后的人。

### 3.4.1 主动协商

鼓励服务端的算法选择偏好的表现，叫做主动协商（也叫做，服务端驱动的协商）。选择基于响应可用的表现（他可能会编码的会读，比如语言，内容编码，等），和应用在请求中的各种信息相比，包括章节 5.3 明确的协商域，和暗示特性，比如客户端的网络地址或者用户代理域的一部分。

主动协商是有利地，当用来从可用表现选择的算法很难描述用户代理，后者当服务端期望去发送它的第一个“最佳猜测”响应（希望避免后续请求的往返循环延迟，如果“最佳猜测”对于用户足够好）到用户代理。为了提高服务端猜测，用户代理可能在请求中发送描述它的偏好的头部域。

主动协商有一系列的缺陷：

* 对于服务端来说，为任何给定用户精确决定什么是“最好的”是不可能的，因为这需要对用户代理能力和使用响应的意图十分清楚（比如，用户想要在屏幕上查看还是打印？）；
* 让用户在每一个请求中描述它的能力是非常低效的，并且对用户隐私有潜在的风险；
* 这让服务端的实现和为请求生成响应的算法复杂化；并且
* 限制了响应用于分享缓存的复用性。

用户代理不能依赖主动协商被始终如意的对待，因为源服务端可能没有实现主动协商请求资源，或者可能决定发送一个响应，觉得不确定用户代理的偏好更好，发送一个 406（Not Acceptable）响应。

Vary 头部域（章节 7.1.4）通常会在一个回复内容协商的响应中发送，用来指示请求信息的那一部分用于选择算法。

### 3.4.2 响应协商

响应协商（也叫做，代理驱动协商），选择最好的响应表现（无视状态码）是用户代理在从服务端接收到包含一个列表的可选表现资源的初始响应后用户代理执行的。如果用户代理不满足于初始化响应的表现，可以执行一个 GET 请求在一个或者多个可选资源，选择列表中的元数据，去获取响应不同形式的表现。可选的选择可能会被用户代理自动执行，或者用户从生成的（可能是超文本）菜单手动执行。

注意前面响应表现的引用，通常，资源没有表现。可选的表现只认为目标资源的的表现如果可选的响应提供了作为目标资源（比如，GET 请求的 200（OK）响应）的表现的语义，或者有为目标资源（比如，GET 请求的 300（Multiple Choices））提供链接到可选表现的语义。

一个服务端可能选择不发送一个初始化表现，而是一个可选列表，这指示用户代理最好响应协商。比如，300（Multiple Choice）和 406（Not Acceptable）状态码的响应中的可选列表包含可用表现的信息，所以用户或者用户代理可以通过创建一个选择来交互。

响应协商在响应可能和常见使用唯独有差异（比如类型，语言，或者编码）的时候有利。当源服务端无法决定用户代理的能里，通过检查请求，通常在公共缓存用于分发服务负载和降低网络使用的时候。

响应交互的缺点是传输一个可选列表到用户代理，杂货降低用户感知延迟，如果传输在头部章节，需要第二个请求去获取可替代的表现。而且，这个规格没有定义支持自动选择的机制，尽管也没有防止这类的禁止作为扩展被开发。

### 4. 请求方法

### 4.1 概述

请求方法令牌是请求语义的主要来源；它指示客户端创建这个请求的目的，今儿客户端期待的成功结果。

请求方法的语义可能被更加指定，通过一些存在在请求中的头部域的语义（章节 5），如果这些额外的语义和方法不冲突。比如，一个客户端可以发送条件请求头部域（章节 5.2）去创建一个请求动作条件，基于当前目标资源的状态（\[RFC7232\]）。

```
    method  = token
```

HTTP 起初设计用于作为分发对象系统的接口。请求方法想象为应用语义到一个目标资源，就像调用指定对象定义的方法接收语义。方法令牌区分大小写因为他可能用于一个基于对象的使用大小写敏感的方法名的系统的网关。

不像分布式对象，HTTP 中标准的请求方法不是资源特定的，因为在基于网络的系统\[REST\]中，统一接口为了更好的能见度和复用性提供。一旦定义，一个标准方法应该有相同的语义，当应用于任何资源，尽管每一个资源它自己决定是否实现或者允许这些语义。

这个规格定义了一些在 HTTP 中常见的列标准方法，概括在下面的表哥。为了方便起见，标准方法全部定义为全大写 US-ASCII 字母。  
\| 方法 \| 描述 \| 章节 \|  
\| - \| - \| - \|  
\| GET \| 传输目标资源当前的表现 \| 4.3.1 \|  
\| HEAD \| 和 GET 一样，但是只传输状态行和头部章节 \| 4.3.2 \|  
\| POST \| 在请求负载上执行资源指定的处理 \| 4.3.3 \|  
\| PUT \| 使用请求负载替换当前目标资源的所有表现 \| 4.3.3 \|  
\| DELETE \| 移除目标资源所有的当前响应 \| 4.3.4 \|  
\| CONNECT \| 建立一个到目标资源指定的隧道 \| 4.3.5 \|  
\| OPTIONS \| 为目标资源描述会话选项 \| 4.3.6 \|  
\| TRACE \| 在去往目标资源的路径上执行消息循回测试 \| 4.3.7 \|

所有的通用目的服务端必须支持 GET 和 HEAD 方法。所有其他方法都是可选的。

额外的方法，不在这个规格范围内，已经在 HTTP 中标准化使用。所有这类方法应该被注册在IANA 维护的“Hypertext Protocol \(HTTP\) Method Registry”，定义在章节 8.1。

目标资源允许的方法集合可以被列在一个 Allow 头部域（章节 7.4.1）。然而，语序方法的结合可以动态改变。当服务端接收到无法识别或者为实现的请求方法的时候，源服务端应该响应一个 501（Not Implemented）状态码。当源服务端接收到一个知道但是在目标资源不允许的请求方法的时候，应该响应一个 405（Method Not Allowed）状态码。

### 4.2 普通方法属性

### 4.2.1 安全方法

请求方法被认为是“安全的”，如果他们定义的语义是完全只读的；比如，客户端不请求，并且不期待，任何状态改变发生在源服务器，作为应用安全方法到目标资源的结果。同样的，合理使用安全方法不期待导致任何损害，丢失属性，或者不经常造成服务端的负荷。

安全方法的定义并不能防止一个实现包含有潜在损害的影响，这不是完全刻度的，或者调用一个方法的时候有副作用。重要的是，然而，是客户端没有请求额外的行为，不能对他解释。比如，大部分服务端拼接请求信息到访问日志文件，在每个响应完成的时候，无视方法，这被认为是安全的，尽管日志存储可能会满从而导致服务端中断。同样的一个通过选择网页中的广告的安全请求初始化通常会有改变广告统计的副作用。

在这个规格中定义的请求方法，GET，HEAD，OPTIONS，和 TRACE 方法定义为安全方法。

区分安全和不安全方法的目的是允许自动重新获取处理（爬虫）和缓存性能优化（预获取）工作而不需要担心造成损害。此外，它允许一个用户带是应用适当的约束在自不安全方法的自动使用，当处理潜在不信任内容的时候。

当一个资源在有效请求 URI 中构造这类参数，有选择一个动作的副作用，资源的拥有者有责任去确保动作和方法的语义一致。比如，基于网页的内容编辑器经常在请求参数内使用动作，比如“page?do=delete“，如果这个资源的目标是执行一个不安全动作，则资源的拥有者必须禁止或者不允许这个动作，当它接收使用安全请求方法的时候。不这么做可能会导致不幸的副作用，当自动处理执行一个 GET 在每一个 URI 应用为了连接维护，预获取，创建一个搜索索引，等。

### 4.2.2 幂等性方法

如果多个相同的方法的请求作用在服务端和单个这类请求的效果一样，则认为请求方法是“幂等的”。这个规格定义的请求方法，PUT，DELETE，和安全请求方法都是幂等的。

和安全的定义相同，幂等性属性只应用月用户请求的东西；服务端可以自由的记录每一个请求，维护一个修改控制历史，或者实现掐非幂等的副作用为每一个，幂等请求。

区分幂等方法是因为请求可以自动重复，如果会话失败发生在客户端接收到服务端响应之前。比如，如果一个客户端发送一个 PUT 请求，并且底层连接在响应接收到之前关闭，客户端可以建立一个新的连接，并重试幂等请求。他知道重复请求将会有相同的意图效果，就算源请求成功，并且响应可能不同。

### 4.2.3 可缓存方法

请求方法可以被定义为“可缓存的”，用来指示他们的响应允许被存储用来接下来的使用；更多指定的需求可以看\[RFC7234\]。通常，安全方法不依赖当前或者认证的响应被定义为可缓存的，这个规格定义 GET，HEAD 和 POST 为可缓存，尽管大量主要的缓存实现只支持 GET 和 HEAD。

### 4.3 方法定义

### 4.3.1 GET

GET 方法请求为当前目标资源传输当前选择的表现。GET 是信息重获取的主要机制，注焦了所有的性能优化。因此，人们说通过 HTTP 重新获取信息的时候，通常说的是创建一个 GET 请求。

认为资源标识符和远程文件系统路径名一致和表现是这些文件内容复制的想法很诱人。实际上，这是大部分资源的实现方式（查看章节 9.1 了解相关的安全注意事项）。然而，实际上，没有这种显示。一个资源的 HTTP 接口可能实现为一个内容树对象，在各种数据库记录之上的编程化试图，或者一个连接其他系统的网关。就算当 URI 映射机制被绑到一个文件系统，一个源服务器可能配置去执行文件，将请求作为输入，发送输出作为表现，而不是直接传输文件。只有源服务器需要知道每一个资源标识和一个实现相符，和每一个实现管理在 GET 的响应中去选择和发送目标资源的表现。

一个客户端可以修改 GET 的语义为“范围请求”，请求只传输选择的表现的一部分，通过在请求中发送一个 Range 头部域。

一个 GET 请求消息内的负载没有定义的语义；在 GET 请求发送一个负载正文可能导致一些存在的实现拒绝他们。

一个 GET 请求的响应是可缓存的，一个缓存可能使用它去满足接下来序列的 GET 和 HEAD 请求，除非 Cache-Control 头部域（\[RFC7234\] 的章节 5.2）被指定了。

### 4.3.2 HEAD

HEAD 方法和 GET 相同，除了服务端在响应中必须不发送消息体（比如，响应早头部章节的结尾终止）。服务端必须在响应中发送相同的头部域，就像它发送给 GET 请求，除了负载头部域（章节 3.3）可能缺省.这个方法可以用来获取选中表现的元数据，而不需要传输表现数据，通常用于测试超文本连接的可用性，可访问性，和最近修改。

一个 HEAD 请求消息内的负载没有定义语义；在一个 HEAD 请求内发送一个负载正文可能会导致一些存在的实现去拒绝请求。

HEAD 请求的的响应是可以缓存的；一个缓存可能使用它去满足接下来序列的 HEAD 请求，除非 Cache-Control 头部域\(\[RFC7234\] 的章节 5.2\)指定了其他的。一个 HEAD 响应可能用来作为 GET 的响应；查看 \[RFC7234\] 的章节 4.3.5。

### 4.3.3 POST

POST 方法请求的目标资源处理请求内的表现基于资源自己指定的语义。比如，POST 用于下列功能（在其他内）：

* 提供一个块的数据，比如输入到一个 HTML 表单的域，到一个数据处理进程。
* 发布一个消息到布告栏，新闻组，邮件列表，或者类型的文章组。
* 创建一个还没被源服务端表示的新的资源；和
* 拼接数据到一个资源已经存在的表现。

一个源服务端指定响应语义，通过选择一个适当的状态码，依赖处理 POST 请求的的结果；这个规格定义的所有状态码可能在一个 POST 响应中接收到（除了 206（Partial Content），304（Not Modified），和 416（Range Not Satisfiable））。

如果一个或者多个资源已经在源服务端被创建，作为处理 POST 请求成功的结果，源服务端应该发送一个 201（Created）响应，包含 Location 头部域名，提供一个创建的主资源的标识符（章节 7。1.2）和一个描述请求关联的新资源状态的表述。

POST 请求的响应在包含明确新鲜度信息的时候才可以i 缓存（查看 \[RFC7234\] 的章节 4.2.1）。然而，POST 缓存没有被广泛实现。一个源服务端希望客户端可以求缓存 POST ，可以在之后个 GET 重用，源服务端可能发送一个 200（OK）响应，包含结果，Content-Location 头部域有相同的值作为 POST 的有效请求 URI（章节 3.1.4.2）。

如果处理 POST 的结果和已存在资源的表现相同，一个源服务端可能重定向用户代理到这个资源，通过发送 303（查看其他）响应，Location 域带着已存在资源的标识。这对提供用户代理一个资源标识符并通过一个方法传输表现，更加顺从分享的缓存有好处，尽管以额外的请求为代价，如果用户代理没有表现的缓存。

### 4.3.4 PUT

PUT 方法使用定义在封装在请求消息负载内的表现创建或者替换请求目标资源的状态。给定表现的成功的 PUT 将会建议接下来在相同目标资源的 GET 将会导致相同的表现，被发送在一个 200（OK）响应。然而，没有保证这么一个状态改变将会被观察到，因为目标资源可能被其他用户代理同步操作，或者可能服从源服务端的动态处理，在任何后续的 GET 接收到之前。一个成功的响应只意味着用户代理的意图在那时被打包，当他被服务端处理的时候。

如果目标资源没有当前表现，并且 PUT 成功创建一个，则源服务器博习同志用户代理，通过发送一个 201（Created）响应。如果目标资源没有当前表现，并且表现成功定修改，基于封装的表现的状态，则原服务器必须发送 200（OK）或者 204（No Content）响应去指定成功的完成请求。

一个源服务端应该忽略 PUT 请求中不认识的头部域（比如，不要保存他们作为资源状态的一部分）。

一个源服务端应该验证 PUT 表现和和任何服务端对于目标资源的限制一致，是否可以或将被改变，通过 PUT。这特别重要当源服务端使用内部的配置信息关于 URI，在 GET 响应为表现元数据设置值。当一个 PUT 表现和目标资源不一致，源服务端应该让他们一致，通过传输变现或者改变资源配置，或者响应一个适当的错误信息包含足够的信息去解释为什么表现不适合。409（Conflict）或者 415（Unsupported Media Type）状态码是推荐的，后者专门针对 Content-Type 值有约束。

比如，如果目标资源的 Content-Type 配置为“text/html”并且 PUT 的表现有“image/hpeg”的 Content-Type，源服务端应该做以下一点：

a. 重新配置和目标资源去反映新的媒体类型；

b. 转化 PUT 表现到和资源一致的格式，在保存它作为新的资源状态之前；或，

c. 使用 415（Unsupported Media Type） 响应拒绝请求，表示目标资源限制于“text/html”，可能包含一个连接到其他资源的连接，可能是一个更加适合的新表现。

HTTP 没有精确定义 PUT 方法怎么影响一个源服务端的状态，这超出了用户代理请求的意图和源服务端响应的语义所能表达的。他没有定义一个资源可能是什么，从某种意义上说，超出了 HTTP 提供的接口。它没有定义资源状态是“被存储”，存储如何改变作为资源状态改变的结果，源服务端如何转化资源的结果到表现。通常来说，所有资源接口后边的实现都故意隐藏在服务端后面。

一个源服务端必须不发送一个验证头部域（章节 7.2），比如 ETag 或者 Last-Modified 域，在一个给 PUT 的成功响应，除非请求的表现数据没有任何转化的应用于正文（比如，资源的新表现数据和 PUT 请求接收到数据相同），验证域值反映新表现。这个需求允许用代理直达当表现正文已经在内存中，作为 PUT 的结果，因此不需要从源服务端重新获取，在响应中接收到的验证可以用于未来的条件请求，为了防止意外覆盖（章节 5.2）。

POT 和 PUT 方法的不同主要在于封装的表现的意图不同。POST 请求的目标资源在于处理封装的表现，基于资源自己的语义，然而 PUT 请求封装的表现定义为替换目标资源的状态。因此，PUT 的目标是幂等的，并且对于中介可见，尽管明确的效果只有源服务端直到。

PUT 请求适当的解释假设用户代理知道哪一个目标资源是期待的。一个服务选择一个适合的 URI，代表客户端，在接收到一个状态改变请求之后，应该实现使用 POST 方法而不是 PUT。如果源服务端将不会创建 PUT 请求状态改变到目标资源，而是希望他应用到一个不同的资源，比如当资源被移动到一个不同的 URI，则源服务端必须发送一个适当的 3xx（Redirection）响应；用户代理可能让他的决定无视是否重定向请求。

一个 PUT 请求应用于目标资源可以有副作用在其他资源。比如，一个文章可能有一个 URI 标识“当前版本”（一个资源），使用 URI 表示每一个部分的版本（不同的资源在同一点分享相同的状态，就像当前版本资源）。一个成功的 PUT 请求在“当前版本” URI 可能因此创建一个新的版本资源，为了改变目标资源状态，并且可能导致连接在相关资源之间添加。

一个源服务端允许 PUT 在给定目标资源，必须发送一个 400（Bad Request）给一个包含 Content-Range 头部域名（\[RFC7233\] 章节 4.2）的请求，因为负载可能是部分内容，会错误导致 PUT 一个完全表现。部分内容更新可能指向一个分离的标识资源，和大资源的一部分重合，或者使用不同的方法，专门定义用于部分更新（比如，定义在\[RFC5789\]的PATCH 方法）。

PUT 方法是不能缓存的。如果成功的 PUT 请求穿越一个缓存，有一个或者多个有效请求 URI 的存储响应，则存储的响应将会实现（查看 \[RFC7234\] 的章节 4.4）。

### 4.3.5 DELETE

DELETE 方法请求源服务端移除目标资源和当前功能的关联。在效果上，这个方法和 UNIX 的 rm 命令很像：它表示为一个删除 URI 和源服务端映射的操作，而不是期望删除先前关联的信息。

如果目标资源有一个或者多个当前表现，他们可能或者可能不被源服务端销毁，关联的存储可能或者可能不被回收，完全依赖于资源的性质和源服务端的实现（这不在这个规格的范围内）。同样的，资源其他方便的实现可能需要停用或者归档作为 DELETE 的结果，比如数据库或者网关连接。通常，假设服务端将会只允许 DELETE 发生在资源有规定的机制完成删除。

相对较少的资源允许 DELETE 方法 -- 他主要用于远程认证环境，用户对他的效果有一些了解。比如，一个资源之前使用 PUT 请求创建，或者通过 Location 头部域标识，在一个 201（Created）响应给一个 POST 请求之后，可能允许一个相应的 DELETE 请求去策略这些操作。同样的，自定义用户代理实现实现一个认证公共，比如一个版本管理客户端使用 HTTP 做远程操作，可能使用 DELETE 基于假设服务端的 URI 空间被仔细设备，和版本仓库一致。

如果一个 DELETE 方法成功应用，服务端可能发送一个 202（Accepted）状态码，如果动作可能成功但是还没被执行，一个 204（No Content）状态码，如果动作被执行，但是没有更深入的信息被支持，或者 200（OK）装他妈，如果动作被执行，并且响应消息包含一个表现描述状态。

DELETE 请求消息内的负载没有定义语义；在 DELETE 请求内发送负载正文可能导致一些存在的实现拒绝请求。

DELETE 方法的响应不能被缓存。如果一个 DELETE 请求穿过一个缓存，有一个或者多个存储的响应，对于有效请求 URI，这些请求将会无效化（查看 \[RFC7234\] 的章节 4.4）。

### 4.3.6 CONNECT

CONNECT 方法请求接收者建立一个隧道到请求目标标识的目标源服务端并且，如果成功，之后限制它表现为包的盲转发，在两个方向上，直到隧道关闭。隧道通常用于创建一个端到端虚拟连接，通过一个或者多个代理，可以安全的使用 TLS（传输层安全，\[RFC5246\]）。

CONNECT 只用于请求一个代理。一个接收到一个 CONNECT 请求的服务端可能使用 2xx（Successful）状态码作为响应，指示一个连接已经建立。然而，大部分源服务端没有实现 CONNECT。

一个客户端发送一个 CONNECT 请求必须发送认证格式的请求目标（\[RFC7230\] 的章节 5.3）；比如，请求目标由隧道目标的主机名和端口数字组成，通过冒号分割，比如，

```
    CONNECT server.example:80 HTTP/1.1
    Host: server.example.com:80
```

接收者代理可以创建一个隧道，直接连接请求目标，或者，如果配置使用其他代理，通过转发 CONNECT 请求到下一个入站代理。任何 2xx（Successful）响应指示发送者（和所有入站代理）将会立即切换到隧道模式，在成功响应的头部章节完成的空行之后；在空行之后接收到的数据是来自请求目标标识的服务器。任何不是成功的响应表示隧道没有被组织并且连接依旧由 HTTP 维护。

一个隧道是关闭的，当一个隧道中介检测到两侧都关闭了连接：中介必须尝试发送来自关闭的一侧到另一侧的任何未完成的数据，关闭两侧的连接，并抛弃剩下还没有分发的数据。

代理认证可能用来建立认证去创建一个隧道。比如：

```
    CONNECT server.example.com:80 HTTP:1.1
    Host: server.example.com:80
    Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

在和任意一个服务端建立隧道的时候有重大的风险，特别是目标是众所周知或者保留的 TCP 端口，并不是专门用于网页流量。比如，一个 CONNECT 到一个“example.com:25”请求目标会建议嗲里连接保留的端口使用 SMTP 流量；如果允许，可能会欺骗代理去中继 spam 邮件。支持 CONNECT 的代理应该限制他用于一个有限集合的已知端口或者配置安全请求目标的白名单。

一个服务端必须不发送任何 Transfer-Encoding 或者 Content-Length 头部域，在一个给 CONNECT 的 2xx（Successful） 响应。一个客户端必须忽略任何 CONNECT 接收到的成功响应的 Content-Lenght 或者 Transfer-Enconding 头部域。

CONNECT 请求消息的负载没有定义的语义；在 CONNETCT 请求内发送一个负载正文可能会导致存在的实现拒绝请求。

CONNECT 方法的响应不能缓存。

### 4.3.7 OPTIONAL

OPTIONS 方法请求可用的目标资源的会话选项，源服务端或者一个中介人。这个方法允许客户端决定选项和/或关联资源的需求，或者服务端的能力，没有暗示一个资源动作  
。

OPTIONS 请求通常使用通配符（“_”）作为请求目标（\[RFC7230\] 的章节 5.3）应用于服务端，而不是一个指定的资源。因为一个服务端的会话选项通常依赖于资源，“\_”请求值用于“ping”或者“no-op”类型的方法；它只允许客户端用来测试服务端的能力。比如，用来测试一个代理对于 HTTP/1.1 的一致性（或者缺少）。

如果请求目标不是一个通配符，OPTIONS 请求应用可用的选项，当和目标资源交互的时候。

一个服务端生成一个成功响应给一个 OPTIONS，应该发送任意头部域，可能指示服务端实现和可以应用于目标资源的可选的功能（比如，Allow），包括不在这个规格定义的潜在的扩展。响应负载如果存在，可能也描述了会话选项，以机器或者人类可读的表现。一个标准格式的表现没有定义在这个规格，但是可能定义在未来的 HTTP 扩展。一个服务端伯旭生成一个 Content-Length 域，它的值是“0”，如果没有负载正文被发送在响应中。

一个客户端可能发送一个 Max-Forwards 头部域在一个 OPTIONS 请求去针对请求链中的特定接收者（查阅 章节 5.1.2）。一个代理必须不生成一个 Max-Forwards 头部域，当转发请求的时候，除非请求接收到一个 Max-Forwards 域。

一个客户端生成一个 OPTIONS 请求，包含一个负载正文必须发送一个有效的 Content-Type 头部域，描述表现的媒体类型，尽管这个规格没有定义任何这类负载的使用，未来的 HTTP 扩展可能使用 OPTIONS 的正文去创建更多仔细的查询，关于目标资源。

OPTIONS 方法的响应是不可缓存的。

### 4.3.8 TRACE

TRACE 方法请求一个远程，请求消息应用级别环回。请求的最后接收者应该反映接收到的消息，除了下面描述的一些域，返回客户端作为 200（OK）的消息体，和一个“message/http”（\[RFC7230\] 的章节 8.3.1）的“Content-Type”。最后的接收者是源服务端或者第一个接收到 Max-Forwards 值为 0 的请求（章节 5.1.2）

一个客户端必须不在一个 TRACE 请求生成包含敏感信息的头部域的响应。比如，它会欺骗一个用户代理在 TRACE 请求内发送存储的用户凭证 \[RFC7235\] 或者 cookies \[RFC6265\]。请求最后的接收者应该排除任何可能包含敏感信息的请求头部，当接收者生成响应正文的时候。

TRACE 允许客户端去查看请求链的另一端接收到的数据，并使用数据去测试或者诊断信息。Via 头部域（\[RFC7230\] 章节 5.7.1）的值特别有趣，因为它比阿仙为一个请求链的跟踪。使用 Max-Forwards 头部域允许客户端限制请求链的长度，这对测试代理在一个无限循环内转发消息特别有用。

一个客户端必须不在一个 TRACE 请求内发送一个消息正文。

TRACE 方法的响应不能被缓存。

### 5. 请求头域

一个客户端发送请求头部域提供更多关于请求上下文的信息，让请求附加条件基于目标资源状态，建议响应的首选格式，供应认证凭证，或者修改期待的请求处理。这个域表现的像请求修改符，类似变成语言方法调用的参数。

### 5.1 控制

控制符是请求头部域，指定请求的处理。

\| 头部域 \| 定义在 \|  
\| Cache-Control \| \[RFC7234\] 的章节 5.2 \|  
\| Expect \| 章节 5.1.1 \|  
\| Host \| \[RFC7230\] 的章节 5.4 \|  
\| Max-Forwards \| 章节 5.1 \|  
\| Pragma \| \[RFC7234\] 的章节 5.4 \|  
\| Range \| \[RFC7233\] 的章节 3.1 \|  
\| TE \| \[RFC7230\] 的章节 4.3 \|

### 5.1.1 Expect

在请求中的“Expect”头部域指示一个确定的行为集合（期望），需要被服务端支持，为了适当的处理请求。这个规格只定义了 100-continue 一个期望。

```
    Expect  = "100-continue"
```

Expect 的域值是大小写不敏感的。

一个服务端接收到一个 Expect 域值不是 100-continue 可能响应一个 417（期待失败）状态码是指示不期待的期望不能被满足。

一个 100-continue 期待通知接收者客户端将要发送一个（大概很大）消息正文在请求中希望接收到一个 100（Continue）在响应中，如果请求行和头部域不足以立即取得一个成功，重定向，或者失败响应。这允许客户端等待一个指示，在真的这么做的时候发送消息正文是值得的，可以提高效率，当消息正文太大或者当客户端预期一个错误可能（比如，当发送一个状态该拜年方法，第一次，没有预先验证认证凭证）。

比如，一个请求开始于：

```
    PUT /somewhere/fun HTTP/1.1
    Host: origin.example.com
    Content-Type: video/h264
    Content-Length: 1234567890987
    Expect: 100-continue
```

允许源服务端立即响应一个错误消息，比如 401（Unauthorized）或者 405（Method Not Allowed），在客户端开始使用不需要的数据传输填充管道。

客户端的要求：

* 一个客户端必须不生成一个 100-continue 期待在不包含消息正文的请求。

* 一个客户端将会等待一个 100（Continue）响应在发送请求消息正文之前，不许发送一个 Except 头部域包含一个 100-continue 期待。

* 一个客户端发送一个 100-continue 期待不需要等待任何指定长度的时间；比如一个客户端可能处理去发送消息正文，就算他还没有接收到一个响应。甚至，因为 100（Continue）响应不能发送通过 HTTP/1.0 中介，这么一个可会淡应该不等待一个无限的时间，在发送消息正文之前。

* 一个接收到 417（期待失败）状态码响应的包含 100-continue 期待的响应应该重复请求，不包含 100-continue 期待，因为 417 响应仅仅指定响应链不支持期待（比如，它穿过一个 HTTP/1.0 服务端）。

服务端的需求：

* 一个接收到 100-continue 期待的 HTTP/1.0 请求的服务端必须忽略期待。

* 一个服务端可能不发送一个 100（Continue）响应，如果已经接收到一些或者所有当前请求的消息正文，或者如果帧指示没有消息正文。

* 一个服务端发送一个 100（Continue）响应必须最终发送一个最终状态码，一旦消息正文被接收和被处理，除非连接被意外关闭。

* 一个服务端响应一个最终状态码在读取完整消息正文之前应该指定响应它是否想要去关闭连接或者继续读取和废弃请求消息（\[RFC7230\] 的章节 6.6）。

一个源服务端必须在接收到一个 HTTP/1.1（或者更新）请求行和一个完整头部章节，包含一个 100-continue 期待并指定请求消息正文将会跟随，发送一个立即响应，带着最终状态码，如果状态可以通过检测请求行和头部章节，或者发送一个立即 100（Continue）响应去鼓励客户端去发送请求的消息正文。源服务端必须比等待消息正文，在发送 100（Continue）响应之前。

一个源服务端必须在接收到一个 HTTP/1.1（或者更新）请求行和一个完整头部章节，包含一个 100-continue 期待并指定请求消息正文将会跟随，发送一个立即响应，带着最终状态码，如果状态可以通过检测请求行和头部章节，或者开始转发请求到源服务端，通过发送一个对应的请求行和头部章节到下一个入站服务端。如果代理相信（从配置或者从过去的交互）下一个入站服务端值支持 HTTP/1.0，代理可能生成一个立即 100（Continue）响应去鼓励客户端开始发送消息正文。

注意：Expect 头部域是在 HTTP/1.1 \[RFC2068\] 发布之后才添加的。他是 100（Continue）响应的手段，和指示必须理解的扩展的通用机制。然而，这个扩展机制没有被客户端使用，并且必须理解需求没有被很多服务端实现，是扩展机制无效。这个规格移除了扩展机制，为了简化 100-continue 的定义和处理。

### 5.1.2 Max-Forwards

“Max-Forwards”头部域提供了一个机制，使用 TRACE（章节 4.3.8） 和 OPTIONS（章节 4.3.7）请求方法去限制代理转发请求的限制。这对客户端尝试去跟踪失败或者链中循环的请求请求很有用。

```
    Max-Forwards    = 1*DIGIT
```

Max-Forwards 是一个十进制整数指示请求消息可以被转发的剩下的次数。

每一个中介接收到一个 TRACE 或者 OPTIONS 请求包含一个 Max-Forwards 头部与必须检测和升级他的值，在转发消息之前。如果接收到的值是0，中介必须不转发请求；作为替代，中继必须响应作为最后的接收者。如果接收到的 Max-Forwards 域大于，中介必须生成一个更新的 Max-Forwards 域在转发消息中，它的域值小于 a）接收值减去1，或者 b）接收者最大支持的 Max-Forwards 值。

### 5.2 条件

HTTP 条件请求头部域 \[RFC7232\] 允许一个客户端放置一个前置条件在目标资源的状态，这样方法语义相符的动作将不会应用，如果前置条件验证为假。每一个前置条件定义在这个规格中，在一个从目标资源先前表现获取的一系列验证器和当前选中表现的验证器状态比较（章节 7.2）。因此，这些前置条件验证目标资源的状态是否改变，从一个客户端知道的给定状态。这类验证的效果依赖于方法语义和选择的条件，定义在 \[RFC7232\] 的章节 5。

\| 头部域名字 \| 定义在 \|  
\| If-Match \| \[RFC7232\] 的章节 3.1 \|  
\| If-None-Match \| \[RFC7232\] 的章节 3.2 \|  
\| If-Modified-Since \| \[RFC7232\] 的章节 3.3 \|  
\| If-Unmodified-Since \| \[RFC7232\] 的章节 3.4 \|  
\| If-Range \| \[RFC7232\] 的章节 3.5 \|

### 5.3 内容协商

下面的请求头部域被用户代理发送参与响应内容的主动协商，定义在章节 3.4.1。发送在这些域偏好应用于任何响应内容，包括目标资源的表现，错误或者处理状态的表现，和潜在的甚至可能出现在协议的杂乱的文本字符串。

\| 头部域名字 \| 定义在 \|  
\| Accept \| 章节 5.3.2 \|  
\| Accept-Charset \| 章节 5.3.3 \|  
\| Accept-Encoding \| 章节 5.3.4 \|  
\| Accept-Language \| 章节 5.3.5 \|

### 5.3.1 质量参数

很多请求头部域提供主动协商使用一个普通参数，叫做“q”（大小写不敏感），去赋值一个相关的“权重”到关联类型内容的偏好。这个权重也叫做“quality value”（或者“qvalue”），因为相同的参数名通常用于服务端配置去赋值一个权重到相关的一系列可以被选择的资源的表现的权重。

权重规范化为一个真实的数字，在区间 0 - 1 之间，0.001 是最小的选择，1 是最大的选择；值 0 意味着“不接受”。如果没有“q”参数存在，默认权重是 1。

```
    weight  = OWS ";" OWS "q=" qvalue
    qvalue  = ( "0" [ "." 0*3DIGIT ] )
            / ( "1" [ "." 0*3("0") ] )
```

一个 qvalue 的发送者必须不生成大于3位小数。用户配置这些值应该限制为相同的风格。

### 5.3.2 Accept

“Accept”头部域可以被用户代理用于指定可接受的响应媒体类型。可接受的头部域可以用于指定请求特别限制到一个期望类型的小集合，比如请求一个行内图片。

```
    Accept          = #( media-range [ accept-params ] )
    media-range     = ( "*/*" 
                      / ( type "/"' "*" )
                      / ( type "/" subtype )
                      ) * ( OWS ";" OWS parameter )
    accept-params   = weigth *( accept-ext )
    accept-ext      = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
```

注意：一个用户代理可能提供一个确定媒体范围的默认集合的权重值。然而，除非用户代理是一个关闭的系统，不能和其他渲染代理交互，这个默认集合应该可以被用户配置。

### 5.3.3 Accept-Charset

“Accept-Charset”头部域可以被用户代理发送，用来指定文本响应内容可以接受蛇么字符集。这个域允许用户代理能够更全面理解或者指定目的字符集去标识一个源服务端的能力，能够用这些字符集表现信息。

```
    Accept-Charset  = 1#( ( charset / "*" ) [ weight ] )
```

字符集名字定义在 章节 3.1.1.2。一个用户代理可能为每一个字符集关联一个权重值，用来指定用户对于这个字符集相关的偏好，定义在章节 5.3.1。一个栗子时是：

```
    Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

特殊值“_”，如果在 Accept-Charset 域中存在，匹配任何不在 Accept-Charset 域中提到的字符集。如果没有“\_”存在在 Accept-Charset 域中，则域中任何没有明确提及的字符集被认为是客户端“不可接受的”。

一个请求没有 Accept-Charset 头部域暗示用户代理将会接受任何字符集在响应中。大部分通用目的的用户代理不发送 Accept-Charset，除非特别配置这么做，因为一个详细的支持字符集列表让服务端可以更简单的通过用户代理请求特征识别个人，的美德（章节 9.7）。

如果 Accept-Charset 头部域不在请求中存在，并且响应没有可用的表现有字符集被列为可接受，源服务端可以尊重头部域，通过发送一个 406（Not Acceptable）响应，或者抛弃头部域，通过对待资源香是没有参与内容协商。

### 5.3.4 Accept-Encoding

“Accept-Encoding”头部域可以被用户代理用来指定响可以接受什么内容编码。一个“identity”令牌用来作为“没有编码”的代名词，为了当编码不存在的时候作为首选。

```
    Accept-Encoding = #( coding [ weight ] )
    codings         = content-coding / "identity" / "*"
```

每一个编码值可能给定一个关联的权重值，标识编码的偏好，定义在章节 5.3.1。通配符“\*”符号在一个 Accept-Encoding 域匹配任何没有在头部域明确列出的内容编码。

比如，

```
    Accept-Encoding: compress, gzip
    Accept-Encoding: 
    Accept-Encoding: *
    Accept-Encoding: compress;q=0.5, gzip;q=1.0
    Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

一个请求没有 Accept-Encoding 头部域暗示用户代理没鱼哦首选考虑的内容编码。尽管这允许服务端使用任何内容编码在响应中，这不意味着用户代理能够正确处理所有的编码。

一个服务端测试一个内容编码对于给定表现是否可接受，使用下列规则：

1. 如果 Accept-Encoding 域在请求中，任何内容编码被用户代理认为是可接受。

2. 如果表现没有内容编码，默认被认为是可接受，除非特别排除，通过 Accept-Encoding 域标记为“identity;q=0”卓恶化“\*;q=0”没有任何更多“identity”指定条目。

3. 如果表现的内容编码是列在 Accept-Encoding 中的内容编码，它是可接受的，除非他伴随着一个 qvalue 为 0。（定义在掌机 5.3.1，qvalue 为 0 意味着“不可接受”）。

4. 如果多个内容编码是可以被接受的，则有着最高的非0的 qvalue 的可接受的内容编码是首选。

一个 Accept-Encoding 头部域的域值结合起来是空的，意味用户代理不想要响应有任何内容编码。如果一个 Accept-Encoding 头部域在请求中存在，对于响应没有任何可用的表现，它的内容编码作为可接受被列出，源服务端应该发送一个响应，不带任何内容编码。

注意：大部分 HTTP/1.0 应用不认识或者遵守内容编码关联的 qvalue。这意味着 qvalue 可能不工作，也不允许 x-gzip 或者 x-compress。

### 5.3.5 Accept-Language

“Accept-Language”头部域可以被用户代理用来指定响应中自然语言集合的首选。语言标签定义在章节 3.1.3.1。

```
    Accept-Language = 1#( language-range [ weight ] )
    language-range  = <language-range, 查看 [RFC4647] 的章节 2.1>
```

每一个 language-range 可以给定一个关联的 qvalue 值，表示用户对该范围指定的语言的偏爱估计，定义在掌机 5.3.1。比如，

```
    Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

意味着：“我喜欢 Danish，但是也接受 British English 和 其他类型的 English”。

一个请求没有任何 Accept-Language 头部域意味着用户代理将会接受任何语言在响应中。如果头部域在请求中存在，响应没有任何可用的表现命中语言标签，源服务端可以无视头部域，通过对待响应就像他没有参与内容协商，或者尊重头部域，发送一个 406（Not Acceptable）响应。然而，后者是不鼓励的，应为这么做可以防止用户访问他们可以使用的内容（使用翻译软件，比如）。

注意一些接收者对待语言标签中的顺序，降序优先列出，特别是那些赋值相同权重值的（没有值意味着 q=1）。然而，这个行文不能被依赖，为了一致性和最大化可操作性，很多用户代理赋值每一个语言标签一个唯一的权重值，当然也以权重降序列出。关于语言优先级列表更多的讨论可以在 \[RFC4647\] 章节 2.3 中找到。

为了匹配，\[RFC4647\] 的章节 3 定义了一些列匹配方案。实现可以提供最适合的匹配方案，为了他们的需求。“Basic Filtering”方案（\[RFC4647\] 的章节 3.3.1）和前面定义在 \[RFC2616\] 章节 14.4 中为 HTTP 中定义的一样。

在每一个请求中发送一个 Accept-Language 头部域（章节 9.7），带着完整的语言学偏好，可能和用户隐私期望有所未违背。

因为清晰度是高度依赖每个用户的，用户代理需要允许用户完全控制语言学偏好（通过配置用户代理或者通过用户可控的系统设置默认）。一个用户代理无法提供这种控制给用户必须不发送一个 Accept-Language 头部域。

注意：用户代理应该提供用户指南，当设置一个偏好的时候，因为用户仅仅熟悉前面描述匹配的语言的详情。比如，用户假设选择“en-gb”，他们会提供任何类型的 English 文档，如果 British English 不可用。一个用户代理可能加一，在这种场景中，添加“en”到列表，为了更好的命中行为。

### 5.4 认证凭证

两个头部域用来携带认证凭证，定义在 \[RFC7235\]。注意，很多自定义用户认证机制使用 Cookie 头部域来打达到这个目的，定义在 \[RFC6265\]。

\| 头部域名字 \| 定义在 \|  
\| Authorization \| \[RFC7235\] 的章节 4.2 \|  
\| Proxy-Authorization \| \[RFC7235\] 的章节 4.4 \|

### 5.5 请求上下文

下面的请求头部域提供额外的请求上下文信息，包含用户，用户代理和请求背后的资源的信息。

\| 头部域名字 \| 定义在 \|  
\| From \| 章节 5.5.1 \|  
\| Referer \| 章节 5.5.2 \|  
\| User-Agent \| 章节 5.5.3 \|

### 5.5.1 From

“From”头部域包含一个控制发送请求的用户代理的用户的互联网邮件地址。这个地址应该是机器使用的，被“mailbox”定义在 \[RFC5322\] 的章节 3.4。

```
    From    = mailbox
    mailbox = <mailbox, 查看 [RFC5322] 的章节 3.4>
```

一个栗子是：

```
    From: webmaster@example.org
```

From 头部域仅仅被非机器人用户代理发送。一个用户代理不应该发送一个 From 头部域，在没有被用户明确配置的情况下，因为这可能和用户的隐私喜好或者他们站的安全策略有冲突。

一个机器的用户带应该发送一个有效的 From 头部域，这样负责运行机器的用户可以被联系，如果服务出现问题，比如机器发送过多不想要的，或者无效的请求。

一个服务端不应该使用 From 头部域做访问控制或者认证，因为大部分接收者或假设域值是公共信息。

### 5.5.2 Referer

“Referer”\[sic\] 头部域允许用户代理指定一个 URI 作为获取目标资源的引用（比如，“referrer”，尽管域名拼写错误）。一个用户代理必须不将片段和用户信息组件包含在 URI 引用 \[RFC3986\] 中，如果存在，当生成Referer 域值。

```
    Referer = absolute-URI / partial-URI
```

Referer 头部域允许服务端去生成返回链接到其他资源，为了简单的分析，记录，优化缓存，等。一些服务端使用 Referer 头部域作为拒绝来自其他站点的手段（也叫做“deep linking”）或者限制跨站请求微站（CSRF），但是不是所有的请求包含它。

栗子：

```
    Referer: http://www.example.org/hypertext/Overview.html
```

如果目标 URI 获取来自一个没有他自己的 URI 的资源（比如，用户键盘输入，或者用户的书签/收藏的条目），用户代理必须排除 Referer 域或者发送“about:blank"作为值。

Referer 域可能潜在披露请求上下文或者用户浏览器历史信息，这是一个隐私问题，如果引用资源披露个人信息（比如账户名字）或者一个资源被认为是机密（比如在防火墙后面或者安全服务内部）。大部分通用目的用户代理不发送 Referer 头部域，当引用资源是本地“file”或者“data” URI。一个用户代理必须不发送一个 Referer 头部域，在一个不敢圈 HTTP 请求，如果引用页面在一个安全协议接收到。查看章节 9.4 了解额外的安全注意事项。

已知一些中介不加选择的移除外出的请求。这有不幸运的副作用，干扰了 CSRF 攻击防御，这对他们用户损害更大。中介和用户代理扩展希望限制 Referer 中披露的信息应该限制他们的修改为特定编辑，比如覆盖内部域名，使用假名或者阶段查询和/或路径组件。一个中介应该不修改或者删除 Referer 头部域，当域值和请求目标有相同的方案和主机的时候。

### 5.5.3 User-Agent

“User-Agent”头部域包含发起请求的用户代理的信息，通常被服务端用于帮助确定报告的可操作性问题范围，解决或者调整响应去避免特定用户代理的限制，为了分析无视浏览器或者操作系统使用。一个用户代理应该发送一个 User-Agent 域在每一个请求中，除非特别配置不要这么做。

```
    User-Agent  =   product *( RWS ( product / comment ) )
```

User-Agent 域值由一个或者多个产品标识组成，每一个跟随着零个或者多个评论（\[RFC7230\] 的章节3.2），收集用户代理软件和他的重大自版本标识。为了方便，产品标识按识别用户代理软件的意义降序排列。每一个产品表示由一个名字和可选的版本构成：

```
    product         = token [ "/" product-version ]
    product-version =token
```

一个发送者应该限制生成产品标识为标识一个产品必须的东西；一个发送者必须不生成广告或者其他不需要的信息，在产品标识内。一个发送者应该不在产品版本内生成不是版本标识的信息（比如，相同产品的产品标识连续的版本应该只有产品版本部分不同）。  
栗子：

```
    User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

一个用户代理应该不生成 User-Agent 域包含不需要力度的详情，过于长和详细的 User-Agent 域值增加请求延迟和用户被识别的应用风险（“指纹”）。

同样的，实现鼓励不去使用其他象限的产品令牌，为了声明和他们的兼容性，这规避了这个域的目标。如果一个用户代理伪装成一个不同的用户代理，接收者可以假设用户意图期待看到为这个用户代理标识量身定做的响应，即使他们并不能工作的和真实用户代理一样好。

### 6. 响应状态码

状态码元素是一个3位数字码，给出尝试去理解和满足请求的结果。

HTTP 状态码是可扩展的。HTTP 客户端不需要去理解所有注册的状态码的意义，尽管这种理解很明显是期望的。然而，一个客户端必须理解状态码的类别，由第一位指定，对待不认识的状态码就像对待这类 x00 状态码，除了一个接收者必须不缓存一个不认识的状态码的响应。

比如，如果一个不认识的状态码 471 被客户端接受，客户端可以假设一些错误发生在请求上，并且对待响应就像接收到一个 400（Bad Request）状态码。响应消息通常将会包含解释这个状态的表现。

状态码第一位数字定义了响应的类型。后两位数字没有角色类别。对于第一位数字，有 5 个值：

* 1xx（Infomation）：请求已经被接受，继续处理。

* 2xx（Successful）：请求成功被接受，理解，并接受。

* 3xx（Redirection）：更多的动作需要被执行，为了完成请求。

* 4xx（Client Error）：请求包含坏的语法或者不能被满足。

* 5xx（Server Error）：服务端失败去满足一个明显有效的请求。

### 6.1 状态码概述

定义在这个规格的状态码列在下面，\[RFC7232\] 章节4，\[RFC7233\] 章节4，\[RFC7235\] 章节3。列在这里的原因语句只是推荐 -- 他们可以被本地等效替换而不影响协议。

带着这个规格中定义为默认可被缓存的状态码的响应（比如，这个规格中的 200，203，204，206，300，301，404，405，410，414，和 501）可以被一个缓存重新使用，启发式过期，除非方法in 工艺指定其他或者明确的缓存控制 \[RFC7234\]；所有其他状态码默认不可缓存。

| 码 | 原因语句 | 定义在... |
| --- | --- | --- |
| 100 | Continue | Section 6.2.1 |
| 101 | Switching Protocols | Section 6.2.2 |
| 200 | OK | Section 6.3.1 |
| 201 | Created | Section 6.3.2 |
| 202 | Accepted | Section 6.3.3 |
| 203 | Non-Authoritative Information | Section 6.3.4 |
| 204 | No Content | Section 6.3.5 |
| 205 | Reset Content | Section 6.3.6 |
| 206 | Partial Content | Section 4.1 of \[RFC7233\] |
| 300 | Multiple Choices | Section 6.4.1 |
| 301 | Moved Permanently | Section 6.4.2 |
| 302 | Found | Section 6.4.3 |
| 303 | See Other | Section 6.4.4 |
| 304 | Not Modified | Section 4.1 of \[RFC7232\] |
| 305 | Use Proxy | Section 6.4.5 |
| 307 | Temporary Redirect | Section  6.4.7 |
| 400 | Bad Request | Section 6.5.1 |
| 401 | Unauthorized | Section 3.1 of \[RFC7235\] |
| 402 | Payment Required | Section 6.5.2 |
| 403 | Forbidden | Section 6.5.3 |
| 404 | Not Found | Section 6.5.4 |
| 405 | Method Not Allowed | Section 6.5.5 |
| 406 | Not Acceptable | Section 6.5.6 |
| 407 | Proxy Authentication Required | Section 3.2 of \[RFC7235\] |
| 408 | Request Timeout | Section 6.5.7 |
| 409 | Conflict | Section 6.5.8 |
| 410 | Gone | Section 6.5.9 |
| 411 | Length Required | Section 6.5.10 |
| 412 | Precondition Failed | Section 4.2 of \[RFC7232\] |
| 413 | Payload Too Large | Section 6.5.11 |
| 414 | URI Too Long | Section 6.5.12 |
| 415 | Unsupported Media Type | Section 6.5.13 |
| 416 | Range Not Satisfiable | Section 4.4 of \[RFC7233\] |
| 417 | Expectation Failed | Section 6.5.14 |
| 426 | Upgrade Required | Section 6.5.15 |
| 500 | Internal Server Error | Section 6.6.1 |
| 501 | Not Implemented | Section 6.6.2 |
| 502 | Bad Gateway | Section 6.6.3 |
| 503 | Service Unavailable | Section 6.6.4 |
| 504 | Gateway Timeout | Section 6.6.5 |
| 505 | HTTP Version Not Supported | Section 6.6.6 |

注意这个列表不是启发式的 -- 没有包括定义在其他规格中扩展的状态码。完整的列表由 IANA 维护。查阅章节 8.2 了解更多详情。

### 6.2 信息 1xx

1xx（Infomational）类的状态码指示临时响应，为了会话连接状态或者请求处理，在完整请求动作和发送最终响应之前。1xx 响应在状态行后的第一个空行结束（空行表示头部章节的结束）。因为 HTTP/1.0 没有定义任何 1xx 状态码，一个服务端必须不发送一个 1xx 响应给 HTTP/1.0 客户端。

一个客户端必须可以转化一个或者多个 1xx 响应，在接收最终响应之前，即使客户端不希望接收。一个用户代理可能忽略不期望的 1xx 响应。

一个代理必须转发 1xx 响应，除非代理自己请求生成 1xx 响应。比如，如果代理添加一个“Expect: 100-continue”域当他转发一个请求，则它不需要转发对应的 100（Continue）响应（们）。

### 6.2.1 100 Continue

100（Continue）状态码只是初始部分的请求已经被接受，并且还没有被服务端拒绝。服务端希望在请求被完全接收并执行之后发送最后的响应。

当请求包含一个 Expect 头部域，它的期望是 100-continue，100 响应只是服务端虚妄接收请求负载正文，定义在章节 5.1.1。客户端应该继续发送请求并抛弃 100 响应。

如果请求不包含 Except 头部域包含 100-continue 期望，客户端可以简单抛弃临时响应。

### 6.2.2 101 Switching Protocols

101（Switching Protocols）状态码指示服务端服从客户端的请求，通过 Upgrade 头部域（\[RFC7230\] 的章节 6.7），改变在连接中使用的应用协议。服务端必须生成一个 Upgrade 头部域在响应中，指示哪一个协议将会被切换，在终止 101 响应的空行之后立即。

假设服务端将只统一切换协议，当这么做有好处的时候。比如，切换一个更新版本的 HTTP 比旧版本有优点，切换到实时，同步协议可能有优势，当分发资源使用这些功能。

### 6.3 成功 2xx

2xx（Successful）类的状态码指示客户端的请求被成功接收，理解，和接受。

### 6.3.1 200 OK

200（Successful） 状态码指示请求是成功的。200 响应中发送的负载依赖于请求方法。对于定义在这个规格的方法，负载的意图可以概括为：

* GET，目标资源的表现

* HEAD，和 GET 一样的表现，但是没有表现数据

* POST，动作状态的表现，或者获取结果的表现

* PUT，DELETE，动作的状态的表现

* OPTIONS，会话选项的表现

* TRACE，最终服务端接收到的请求消息的表现

除了 CONNECT 响应，一个 200 响应总是有负载，尽管一个源服务端可能生成一个负载正文，长度为0。如果不希望有负载，一个源服务端应该发送 204（No Content）代替。对于 CONNECT，不允许负载是因为成功的结果是一个隧道，在 200 响应的头部章节之后立马开始。

一个 200 响应默认是可以缓存的；比如没除非方法定义指定其他或者明确的缓存控制（查看 \[RFC7234\] 对待章节 4.2.2）。

### 6.3.2 201 Created

201（Created）状态码指示请求已经被满足，并且导致一个或者更多新的资源被创建。请求创建的主要资源通过响应中的 Location 头部域标识，或者，如果没有 Location 域接收到，通过有效请求 URI。

201 响应负载通常描述和链接到创建的资源。查阅章节 7.2 了解验证头部域的意义和目标讨论，比如 ETag 和 Last-Modified，在一个 201 响应中。

### 6.3.3 202 Accepted

202（Accepted）状态码只是请求已经被接受并处理，但是处理还没有完成。请求可能或者可能不最终被执行，因为他可能不允许，当处理真实发生的时候。HTTP 中没有从一个异步操作中重新发送一个状态码的场所。

202 响应是故意模糊的。它的目标是允许服务端接受一个请求，为了一些其他处理（可能是一个批量的处理，每台呢只跑一次）而不需要用户代理储蓄连接服务器，直到处理完成。这个响应的表现应该描述请求当前的状态并指出（或者嵌入）一个状态监控，可以提供用户一个请求将会被满足的估计。

### 6.3.4 203 Non-Authoritative Infomation

203（Non-Authoritative Infomation）状态码只是请求成功，但是源服务端返回的 200（OK）响应封装的负载被转化代理修改（\[RFC7230\] 的章节 5.7.2）。状态码允许代理去通知接收者当转化被应用的时候，因为这些只是可能影响关于内容的决定。比如，更多缓存验证请求内容可能只应用于相同的请求路径（经过相同的代理）。

203 响应和 Warning 214 Transformation Applied（\[RFC7234\] 的章节 5.5）类似，它的有点事可以应用于任何状态码的响应。

一个 203 响应默认是可以缓存的；比如，除非方法定义指定其他或者明确的缓存控制（\[RFC7234\] 的章节 4.2.2）。

### 6.3.5 204 No Content

204（No Content）状态码指示服务端成功满足了请求，并且没有额外的内容去发送在响应负载正文，响应头部域中的元数据引用目标资源和他选中的表现，在请求动作被应用之后。

比如，如果一个 204 状态码在一个 PUT 请求的响应中被接收，并且响应包含 ETag 头部域，则 PUT 是成功的，并且 ETag 域值包含目标资源新表现实体标签。

204 响应允许服务端去指定动作被成功应用到目标资源，暗示用户代理不需要去遍历它当前的“文档视图”（如果存在）。服务端假设用户代理将提供一些成功的指示给用户，基于它自己的接口，应用任何新的或者更新元数据在响应到它的活跃表现。

比如，一个 204 状态码通常在文档编辑接口中使用，表示一个“保存”操作，表示文档被保存，依旧过可以给用户去编辑。也经常在自动化数据传输接口中使用，比如在分布式控制系统中使用。

一个 204 响应被头部域之后的第一个空行终止，因为它不能包含一个消息体。

一个 204 响应默认可以被缓存，比如，除非方法定义指定其他，或者明确的缓存控制（查看 \[RFC7234\] 的章节 4.2.2）。

### 6.3.6 205 Reset Content

205（Reset Content）状态码指示服务端已经满足请求并且期望用户代理重新设置“文档视图”，这将导致请求被发送，到他从源服务器接收到的原始的状态。

这个响应是为了支持普通数据条目使用场景，用户接收内容支持内容条目（一个表单，笔记本，画布，等），在空间内输入或者操作数据。导致输入的数据通过一个请求被提交，然后数据条目机制被重设为下一个条目，这样用户可以简单的初始化其他输入动作。

因为 205 状态码暗示没有额外的内容将会被提供，一个服务端必须不生成负载，在一个 205 响应内。换句话说，一个服务端必须为 205 响应做下面的其中一项：a）指定一个 0 长度的正文，为响应，通过包含一个值为 0 的 Content-Length 头部域；b）指定一个 0 长度的负载，为响应，通过包含一个 Transfer-Encoding 头部域，它的值是 chunked，消息正文由单个 0 长度的 chunk 构成；c）在发送一个终止头部章节的空行之后立即关闭连接。

### 6.4 重定向 3xx

3xx（Redirection）类的状态码指示用户代理需要采取下一步的行动去满足请求。如果提供了一个 Location 头部域（章节 7.1.2），用户代理可能自动重定向请求到 Location 域值引用的 URI，就算指定的状态码不理解。自动重定向需要小心执行，如果方法不知道是否安全，定义在章节4.2.1，因为用户可能不希望重定向不安全请求。

有多种类型的重定向：  
1. 指示资源可能可以在一个不同的 URI 可以获取到的重定向，通过提供 Location 域，在状态码 301（Moved Permanently），302（Found），和 307（Temporary Redirect）。

1. 提供命中资源的选择的重定向，每一个都表示源请求目标，在 300（Multiple Choice）状态码。

2. 重定向到不同的资源，通过 Location 域标识，可以表示一个重定向响应为请求，在 303（See Other）状态码。

3. 重定向到之前缓存的结果，在 304（Not Modified）状态码。

注意：HTTP/1.0 中，状态码 301（Moved Permanently）和 302（Found）定义为第一种类型的重定向（\[RFC1945\] 的章节 9.3）。早期用户代理根据应用于重定向目标的方法是否和原始气球一致或者被重写为 GET 分割。尽管 HTTP 原始定义 201 和 302（为了匹配他原始实现，在 CERN）为前一种语义。并定义 303（See Other）去匹配后一种语义，普遍的实现组件也覆盖后一种语义，为 301 和 302。HTTP/1.1 的第一次修改添加了 307（Temporary Redirect）去指示前一种语义，为了不和有分歧的实现冲突。过去 10 年以后，大部分用户代理依旧为 301 和 302 做方法覆盖；然而，这个规格让行为符合，当原始请求为 POST 的时候。

一个客户端应该检测并介入重定向循环（比如，“无限”重定向循环）。

注意：一个早期版本的规格推荐一个最大 5 次重定向（\[RFC2068\]，章节 10.3）。内容开发者需要意识到一些客户端可能实现这么一个固定的限制。

### 6.4.1 300 Multiple Choice

300（Multiple Choice）状态码指示目标资源有多于一个表现，每一个有它自己的指定标识，关于选择的信息被提供，这样用户（用户代理）可以选择一个首选的表现通过重定向它的请求到一个或者多个这些标识符。换句话说，服务端期望用户代理参与主动协商去选择最适合的表现，按照它的需要（章节 3.4）。

如果服务端有一个首选选择，服务端应该生成一个 Location 头部域，包含一个首选选择的 URI 引用。用户代理可能使用 Location 域值去自动重定向。

对于不是 HEAD 的请求方法，服务端应该生成一个负载，在 300 响应中，包含一个表现列表元数据和 URI 引用，用户或者用户代理可以选择最喜欢的一个。用户代理可能创建一个选择，从列表中，自动的，如果它理解提供的媒体类型。一个自动选择的特殊格式没有定义在这个规格，因为 HTTP 尝试去维护正式的去定义它的负载。在实践中，表现通过一些简单转化的格式提供，相信可以被用户代理接收，取决于分享的设计或者内容协商，或者在一些普通接收的超文本格式。

一个 300 响应默认是可缓存的，除非通过方法定义指定或者明确的缓存控制（\[RFC7234\] 的章节 4.2.2）。

注意：300 状态码原本的提议是定义头部域提供一个可选表现列表，这样他可以被 200，300，和406 响应使用，可以被 HEAD 方法响应传输。然而，缺少部署和反对语法让 URI 和可选（子提议）被从这个规格移除。使用一个集合的 Link 头部域 \[RFC5988\] 和列表交流是可能的，每一个带有一个“alernat”关系，尽管部署是一个鸡生蛋问题。

### 6.4.2 301 Moved Permanently

301（Moved Permanently）状态码指示目标资源赋值一个新的永久的 URI，并且任何以后的引用到这个资源应该使用封闭的 URI 中的一个。有连接编辑能力的客户端应该自动重新连接引用到有效请求 URI 到一个或者新引用，通过服务端发送，可能。

服务端应该生成一个 Location 头部域在响应中包含首选 URI 引用新的永久 URI。用户代理可能使用 Location 域值做自动重定向。服务端响应负载通常包含一个短的超文本笔记，和一个到新 URI 的超链接。

注意：因为历史原因，用户代理可能该拜年请求方法，从 POST 到 GET，为接下来的请求，如果这个行为是不期望的，307（Temporary Redirect）状态码可以用来代替。

一个 301 响应默认可以缓存；比如，除非方法定义指定其他，或者明确的缓存控制（\[RFC7234\] 的章节 4.2.2）。

### 6.4.3 302 Found

302（Found）状态码指定目标资源临时居住在一个不同的 URI 下。因为重定向可能偶尔改变，客户端应该继续使用有效请求 URI 为其他的请求。

服务端应该生成一个 Location 头部域在响应中，包含一个 URI 引用一个不同的 URI。用户代理可能使用 Location 域值做自动重定向。服务端的响应负载通常包含一个短的超链接备注和一个超链接到其他不同的 URI。

注意：因为历史原因，一个额用户代理可能改变请求方法，从 POST 到 GET，为接下来的请求。如果这个行为是不期望的，307（Temporary Redirect）状态码可以替代使用。

### 6.4.4 303 See Other

### 6.4.5 305 Use Proxy

305（Use Proxy）状态码定义在这个规格的前一个版本，现在已经弃用。

### 6.4.6 306 \(Unused\)

306 状态码定义在这个规格的上一个版本，不再使用，这个码保留。

### 6.4.7 307 Temporary Redirect

307（Temporary Redirect）状态码指示目标资源临时居住在一个不同的 URI 下，用户代理必须不改变请求方法，如果执行一个自动的重定向到那个 URI。因为重定向会随着时间改变，客户端应该继续使用原始的有效请求 URI，为将来的请求。

服务端应该生成 Location 头部域在响应中包含一个 URI 引用不同的 URI。用户代理可能使用 Location 的域值去自动重定向。服务端的响应负载通常包含一个短超链接记录一个超链接到一个不同的 URI。

注意：这个状态码和 302（Found）很像，除了他不允许该拜年请求方法，从 POST 到 GET。这个规格定义和 301（Moved Permanently）不相等（\[RFC7238\]，然而，定义状态码 308（Permanent Redirect）为了这个目的）。

### 6.5 客户端错误 4xx

4xx（Client Error）类的状态码指示客户端发生错误。除了响应一个 HEAD 请求，服务端应该发送一个表现包含一个错误场景的解释，和是否这是临时的或者永久的状况。这些状态码应用于任何请求方法。用户代理应该显示任何包含的表现给用户。

### 6.5.1 400 Bad Request

400（Bad Request）状态码指示服务端无法或者不会处理请求，因为感知到一些用户端的错误（比如，畸形格式的请求语法，不合法的请求消息帧，或者欺骗性的请求路由）。

### 6.5.2 402 Payment Required

402（Payment Required）状态码保存以便未来使用。

### 6.5.3 403 Forbidden

403（Forbidden）状态码指示服务端理解请求但是拒绝认证它。一个服务端希望创建公告解释请求被禁止的原因可以描述在响应负载（如果存在）。

如果认真凭证在请求中被提供，服务端认为他们不足以授权访问。客户端应该不自动重复请求，使用相同的凭证。客户端可能重复请求，使用新的或者不同的凭证。然而，一个请求可能被禁止的原因和凭证不相关。

一个源服务端希望去“隐藏”一个当前存在的禁止目标资源可能使用 404（Not Found）状态码作为响应。

### 6.5.4 404 Not Found

404（Not Found）状态码指示服务端没有找到目标资源的当前变现，或者不愿意去显露它的存在。一个 404 状态码不指示表现的缺失是临时的还是永久的；410（Gone）状态码比 404 更加适合，如果源服务器知道，大概通过一些配置搜端，状况可能是永久的。

一个 404 响应默认是可缓存的，除非方法定义指定其他或者明确的缓存控制（\[RFC7234\] 的章节 4.2.2）。

### 6.5.5 405 Method Not Allowed

405（Method Not Allowed）状态码指示请求行中接收到的方法是服务端知道的，但是不被目标资源支持。源服务器必须生成一个 Allow 头部域在一个 405 响应中，包含一个列表的目标资源当前支持的方法。

一个 405 响应默认是可以缓存的；比如，除非方法定义指定其他或者明确的缓存控制（\[RFC7234\] 的章节 4.2.2）。

### 6.5.6 406 Not Acceptable

406（Not Accepted）状态码指示目标资源没有当前的表现可以被用户代理接受，基于主动协商头部域名，在接收到的请求中（章节 5.3），服务端不愿意提供一个默认的表现。

服务端应该生成一个负载包含一个可用表现特性和对应资源标识符的列表，这样用户或者用户代理可以选择一个最合适的。一个用户代理可能自动选择最合适的选择，从列表中。然而，这个规格没有定义任何标准，用来自动选择，定义在章节 6.4.1。

### 6.5.7 408 Request Timeout

408（Request Timeout）状态码指示服务端没有接收到完整的请求消息，在他准备去等待的时间内。一个服务端应该发送“close”连接选项（\[RFC7230\] 的章节 6.1）在响应中，因为 408 暗示服务端决定关闭连接而不是继续等待。如果客户端有一个挂起的请求在过境，客户端可能重复请求在一个新的连接。

### 6.5.8 409 Conflict

409（Conflict）状态码指示请求不能被完成，因为慕白哦资源当前状态的冲突。这个码使用的场景是，用户可能能够解决冲突并重新提交请求。服务端应该生成负载包含足够的信息给用户去识别冲突源。

冲突最可能发生在一个 PUT 请求的响应中。比如，如果版本被使用并且 PUT 包含资源的改变的表现和更早（第三方）请求冲突，源服务端可能使用一个 409 响应去指示它不能完成请求。在这个场景中，响应表现可能包含可用信息，去何必给不同，基于版本历史。

### 6.5.9 410 Gone

410（Gone）状态码指示目标资源不再可访问，在源服务端，这个状况可能是永久的。如果源服务端不知道，或者没有设施去决定，是否状况是永久的，状态码 404（Not Found）应该使用。

410 响应主要用来协助网页维护的任务，通过通知接收者资源是故意不可用，服务端的拥有者期望远程资源的连接被移除。这种事件通常用于限制事件的，广告服务，和因为资源术语个人，不再关联源服务端的站。不需要去标记所有永久不可用资源为”gone“或者保持标记任意长的时间 -- 这由服务端的拥有者自己决定。

一个 410 响应默认是可以缓存的；比如，除非方法定义指定其他或者明确的缓存控制（\[RFC7234\] 的章节 4.2.2）。

### 6.5.10 411 Length Required

411（Length Required）状态码指示服务端拒绝接受请求，因为没有定义 Content-Length（\[RFC7230\] 的章节 3.3.2）。客户端可能重复请求，如果添加了一个有效的 Content-Lenght 头部域，包含消息正文的长度在请求消息中。

### 6.5.11 413 Payload Too Large

413（Payload Too Large）状态码指示服务端拒绝去处理请求，因为请求的负载大于服务端愿意或者能够处理的。服务端可能关闭连接防止客户端继续请求。

如果这个状况是永久的，服务端应该生成一个 Retrey-After 头部域去指示这是一个临时的，并在什么时候之后客户端可能重试。

### 6.5.12 414 URI Too Long

414（URI Too Long）状态码指示服务端拒绝服务请求，因为请求目标（\[RFC7230\] 的章节 5.3）大于服务端愿意去解释的长度。这个罕见的晴空只可能发生在当一个客户端不当的转化一个 POST 请求到一个 GET 请求，使用一个长的查询信息，当客户端下降到一个重定向“黑洞”（比如，一个重定向的 URI 前缀指向它的后缀）或者当服务端在客户端尝试去利用潜在安全漏洞的攻击下。

### 6.5.13 415 Unsupported Media Type

415（Unsupported Media Type）状态码指示源服务器拒绝服务请求，因为负载负载的格式这个目标资源的方法不支持。格式问题可能是因为请求的指定 Content-Type 或者 Content-Encoding，或者直接检查数据的结果。

### 6.5.14 417 Expectation Failed

417（Expectation Failed）状态码指示请求的 Expect 头部域给定的期望（章节 5.1.1）至少有一个入站服务无法被满足。

### 6.5.15 426 Upgrade Required

426（Upgrade Required）状态码指示服务端拒绝去执行请求，使用当前的协议，但是愿意这么做，在客户端升级到一个不同的协议。服务端必须发送一个 Upgrade 头部域在一个 426 响应去指定需要的协议（\[RFC7230\] 的章节 6.7）。

栗子：

```
    HTTP/1.1 426 Upgrade Required
    Upgrade: HTTP/3.0
    Connection: Upgrade
    Content-Length: 53
    Content-Type: text/plain

    this service requires use of the HTTP/3.0 protocols.
```

### 6.6 服务端错误 5xx

5xx（Service Error）类的状态码指示服务端意识到有一个错误发生，或者无法执行请求方法。除了响应一个 HEAD 请求，服务端应该发送一个表现包含一个错误场景的解释，和是否是一个临时的或者永久的状。一个用户代理应该显示任何包含的表现给用户，这个响应码可以应用于任何请求方法。

### 6.6.1 500 Internal Server Error

500（Internal Server Error）状态码指示服务端遭遇了一个不期待的状况，阻止他满足请求。

### 6.6.2 501 Not Implemented

501（Not Implemented）状态码指示服务端不支持满足请求需要的功能。这是适合的响应，当服务端不认识请求方法，并且没有能力为任何资源支持它。

一个 501 响应默认可以被缓存；比如，除非方法定义指定或者明确的缓存控制（\[RFC7234\] 的章节 4.2.2）。

### 6.6.3 502 Bad Gateway

502（Bad Gateway）状态码指示服务端表现得像一个网关或者代理的时候，接收到一个无效的响应，从一个入站服务端，他访问的，当尝试去满足请求。

### 6.6.4 503 Service Unavailable

503（Service Unavailable）状态码指示服务端当前无法处理请求，因为一个临时的过载或者维护时刻表，可能在一些延迟之后缓解。服务端可能发送一个 Retry-After 头部域（章节 7.1.3）去建议一个合适的时间，让客户端去等待，在重试请求之前。

注意：503 状态码的存在不暗示一个服务端使用它，当开始过载。一些服务端可能简单的拒绝连接。

### 6.6.5 504 Gateway Timeout

504（Gateway Timeout）状态码指示服务端，当表现的像一个网关或者代理，没有接收到一个及时的响应，从一个上有服务端，它需要去访问，为了完成请求。

### 6.6.6 505 HTTP Version Not Supported

505（HTTP Version Not Supported）状态码指示服务端没有支持，或者拒绝去支持，请求消息中使用的 HTTP 祝版本。服务端指示无法或者不愿意去使用和客户端相同的主版本去完成请求，定义在 \[RFC7230\] 的章节 2.6，否则跟随着这个错误消息。服务端应该生成一个表现，为 505 响应，描述为什么版本不支持，和服务端支持那些版本。

### 7. 响应头域

响应头部域允许服务端去传递额外关于响应的信息，超出放置在状态行的。这些头部域给出关于服务端的信息，关于接下来访问的目标资源，或者关于相关的资源。

尽管每个响应头部域有定义的意义，通常，精确的语义可能通过请求方法和/或状态码的语义进一步完善。

### 7.1 控制数据

响应头部域可以提供控制数据，不中状态码，指向缓存，或者指示客户端下一步去哪。

| 头部域名称 | 定义在 |
| --- | --- |
| Age | \[RFC7234\] 的章节 5.1 |
| Cache-Control | \[RFC7234\] 的章节 5.2 |
| Expires | \[RFC7234\] 的章节 5.3 |
| Date | 章节 7.1.1.2 |
| Location | 章节 7.1.2 |
| Retry-After | 章节 7.1.3 |
| Vary | 章节 7.1.4 |
| Warning | \[RFC7234\] 的章节 5.5 |

### 7.1.1 原始日期

### 7.1.1.1 Date/Time 格式

在 1995 年之前，有 3种不同格式常用于服务端去交流时间戳。为了和旧的实现兼容，所有三种都定义在这里。首选格式是一个固定长度和单区，Internet Meessage Format \[RFC5322\] 使用的日期和时间规格的子集。

```
    HTTP-dae    = IMF-fixdate / obs-date
```

首选格式的栗子是：

```
    Sun, 06 Nov 1994 08:49:37 GMT   ; IMF-fixdate
```

两个废弃格式的栗子是：

```
    Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
    Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
```

一个接收者转化一个 HTTP 头部域中的时间戳值必须接受所有三种 HTTP-date 格式。当一个发送这生成一个头部域包含一个或者多个时间戳定义为 HTTP-date，发送者必须生成这些时间戳，以 IMF-fixdate 格式。

一个 HTTp-date 值表示一个世界标准时间（UTC）的实例。前两种格式通过 GreenWich Mean Time 三位字母缩写，“GMT”，UTC 名字的前身，指示 UTC；假设 asctime 的值使用 UTC 格式。一个发送者生成 HTTP-date 值，从本地时钟应该使用 NTP（\[RFC5905\]）或则会一些类似协议去同步它的时间到 UTC。

首选格式：

```
    IMF-fixdate   = day-name "," SP detel SP time-of-day SP GMT 
    ; 固定长度/区/大写的格式子集
    ; 查阅 [RFC5322] 的章节 3.3

    day-name     = %x4D.6F.6E ; "Mon", case-sensitive
                  / %x54.75.65 ; "Tue", case-sensitive
                  / %x57.65.64 ; "Wed", case-sensitive
                  / %x54.68.75 ; "Thu", case-sensitive
                  / %x46.72.69 ; "Fri", case-sensitive
                  / %x53.61.74 ; "Sat", case-sensitive
                  / %x53.75.6E ; "Sun", case-sensitive
    date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

     day          = 2DIGIT
     month        = %x4A.61.6E ; "Jan", case-sensitive
                  / %x46.65.62 ; "Feb", case-sensitive
                  / %x4D.61.72 ; "Mar", case-sensitive
                  / %x41.70.72 ; "Apr", case-sensitive
                  / %x4D.61.79 ; "May", case-sensitive
                  / %x4A.75.6E ; "Jun", case-sensitive
                  / %x4A.75.6C ; "Jul", case-sensitive
                  / %x41.75.67 ; "Aug", case-sensitive
                  / %x53.65.70 ; "Sep", case-sensitive
                  / %x4F.63.74 ; "Oct", case-sensitive
                  / %x4E.6F.76 ; "Nov", case-sensitive
                  / %x44.65.63 ; "Dec", case-sensitive
     year         = 4DIGIT

     GMT          = %x47.4D.54 ; "GMT", case-sensitive

     time-of-day  = hour ":" minute ":" second
                  ; 00:00:00 - 23:59:60 (leap second)

     hour         = 2DIGIT
     minute       = 2DIGIT
     second       = 2DIGIT
```

废弃的格式：

```
obs-date     = rfc850-date / asctime-date

     rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
     date2        = day "-" month "-" 2DIGIT
                  ; e.g., 02-Jun-82

     day-name-l   = %x4D.6F.6E.64.61.79    ; "Monday", case-sensitive
            / %x54.75.65.73.64.61.79       ; "Tuesday", case-sensitive
            / %x57.65.64.6E.65.73.64.61.79 ; "Wednesday", case-sensitive
            / %x54.68.75.72.73.64.61.79    ; "Thursday", case-sensitive
            / %x46.72.69.64.61.79          ; "Friday", case-sensitive
            / %x53.61.74.75.72.64.61.79    ; "Saturday", case-sensitive
            / %x53.75.6E.64.61.79          ; "Sunday", case-sensitive


     asctime-date = day-name SP date3 SP time-of-day SP year
     date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
                  ; e.g., Jun  2
```

HTTP-date 是大小写敏感的。一个发送者必须不生成额外的空格，在一个 HTTP-date 超出指定包含一个 SP 的语法。day-name，month，year，和 time-of-day 的语义和 Internet Message Format 相符的名字相同（\[RFC5322\] 章节 3.3）。

rfc850-date 格式的时间戳值的接收者，使用两位数字年份，必须解释一个时间戳，出现在未来 50 年，表现过去最近的年份，有相同的后两位。？？？

时间戳值的接收者鼓励转化时间戳的鲁棒性，除非域的定义有其他限制。比如，个别消息从非 HTTP 源通过 HTTP 转发，可能生成 Internet Message Format 定义的规格的任何日期和时间。

注意：HTTP 对于日期/时间戳格式的需求只应用于协议流中使用。实现不需要去使用这些格式用于用户表现，请求日志，等。

### 7.1.1.2 Date

“Date”头部域表示消息的起源日期和时间，和 Origination Date Field（orig-date）有相同的语义，它定义在 \[RFC5322\] 的章节3.6.1。域值是一个 HTTP-date，定义在章节 7.1.1.1。

```
    Date    = HTTP-date
```

一个栗子是：

```
    Date: Tue, 15 Nov 1994 08:12:31 GMT
```

当 Date 头部域生成的时候，发送者应该生成它的域值为最可用近似消息生成的日期和时间。理论上，日期应该表现负载生成的时刻。在实践中，日期可以在消息起源的任何时间生成。

一个源服务端必须不发送一个 Date 头部域，如果没有去提供一个有效的近似当前世界标准时间的时钟能力。一个源服务端可能发送一个 Date 头部域如果响应是一个 1xx（Infomational）或者 5xx（Server Error）类的状态码。一个源服务端必须发送一个 Date 头部域在所有其他的类型。

一个时钟的接收者接收到一个响应消息，没有一个 Date 头部域必须记录它接收到的时间并拼接一个相符的 Date 头部域到消息头部章节，如果它被缓存或者转发到下游。

一个用户代理发送一个 Date 头部域在请求中，尽管通常不会这么做，除非他相信覆盖有用的信息到服务端。比如，自定义 HTTP 应用解释用户的请求基于用户代理和服务端不同的时钟。

### 7.1.2 Location

“Location”头部域用于一些响应去引用一个和响应相关的指定的资源。关系的类型通过请求方法和状态码语义结合定义。

```
    Location    = URI-reference
```

域值由单个 URI-reference 组成。当它是相对格式（\[RFC3986\] 的章节 4.2）的时候，最终值由它和有效请求 URI 计算而成（\[RFC3986\] 的章节 5）。

如果 Location 值提供在一个 3xx（Redirection） 响应没有片段组件，一个用户代理必须处理重定向，就像值继承 URI 引用的片段组件用于生成请求目标（比如，重定向继承原始引用的片段，如果存在）。

比如，一个为 URI 引用“[http://www.example.org/~trim”生成的](http://www.example.org/~trim”生成的) GET 请求可能导致一个 303（See Other）响应，包含头部域名：

```
    Location: /People.html#trim
```

这建议用户代理重定向到"[http://www.example.org/People.html\#tim"。](http://www.example.org/People.html#tim"。)

同样的，一个为 URI 引用“[http://www.example.org/index.html\#larry”生成的](http://www.example.org/index.html#larry”生成的) GET 请求可能导致一个 301（Moved Permanently）响应包含头部域：

```
    Location: http://www.example.net/index.html
```

这建议用户代理重定向到“[http://www.example.net/index.html\#larry”，保留原始片段标识符。](http://www.example.net/index.html#larry”，保留原始片段标识符。)

有一种状况，Location 值的片段标识符可能不合适，比如，201（Created）响应的 Location 头部域应该提供一个指定到创建资源的 URI。

注意：一些接收者尝试从 Location 域中回复无效的 URI 引用。这个规格没有授权或者定义这类处理，但是为了鲁棒性不允许。

注意：Content-Location 头部域（章节 3.1.4.2）和 Location 的不同之处在于 Content-Location 引用最具体的资源对应的封装的表现。因此响应包含 Location 和 Content-Location 头部域是可能的。

### 7.1.3 Retry-After

服务端发送“Retry-After”头部与去指示用户代理应该等待多长时间，在创建一个后续请求。当在 503（Service Unavailable）响应中一起发送的时候，Retry-After 指示服务多长时间内对于客户端来说不可用用。当和任何 3xx（Redirection）响应一起发送的时候，Retry-After 指示用户代理在发起一个重定向请求之前要求等待的最短时间。

这个域的值可以是 HTTP-date 或者响应接收到的秒数。

```
    Retry-After = HTTP-date / delay-seconds
```

一个 delay-seconds 值是非负十进制整数，表示秒数。

```
    delay-seconds  = 1*DIGIT
```

它使用的两个栗子：

```
     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
     Retry-After: 120
```

在后面的栗子，延迟是 2 分钟。

### 7.1.4 Vary

响应中的“Vary”头部域描述请求消息中的哪一个部分，除了方法，Host 头部域，和请求目标，可能影响源服务端选择和表现这个资源的处理。值由单个通配符（“\*”）或者一个列表的头部域名称（大小写不敏感）构成：

```
    Vary = "*" / 1#field-name
```

Vary 的值为“_”表示任何关于这个请求可能扮演一个角色，在选择响应表现，可能包含消息语法外的元素（比如，客户端的网络地址）。一个接收者无法决定是否这个响应对后续请求合适，没有转发请求到源服务端。一个代理必须不生成一个 Vary 域，带着“\_” 值。

Vary 域值由逗号分离的名字列表指示命名的头部域名，称为选择头部域，可能在选择表现扮演角色。潜在选择头部域不限制于这个规格定义的。

比如，一个响应包含：

```
    Vary: accept-encoding, accept-language
```

指示源服务端可能使用请求的 Accept-Encoding 和 Accept-Language 域（或缺乏）作为决定选择响应内容的因子。

一个源服务端可能发送带一个列表的 Vary，为了两个目的：

1. 为了通知缓存接收者他们不能使用这个响应去满足一个后来的请求除非后来的请求有列表中的域，并且这些域的值和原始请求相同（\[RFC7234\]的章节 4.1）。换句话说，Vary 扩展缓存 key 匹配新请求到存储的缓存条目的需求。

2. 为了通知用户代理接收者这个响应参与内容协商（章节 5.3），并且一个不同的响应可能在后续的请求中发送，如果额外的参数在列出的头部域中被提供。

一个源服务端应该发送 Vary 头部域，当它选择一个表现变化基于请求消息的方面，除了方法和请求目标，除非差异无法跨域或者源服务端故意配置去防止缓存穿透。比如，比如，必须要去发送 Authorization 域名在 Vary，因为跨越用户的重用被域的定义限制（\[RFC7234\] 的章节 5.2）。同样的，一个源服务端可能使用 Cache-Control 指令（\[RFC7234\] 的章节 5.2）取代 Vary，如果认为差异重要性小于 Vary 性能损耗对缓存的影响。

### 7.2 验证头部域

验证头部域表达选中表现的元数据（章节 3）。在安全请求的响应中，验证域描述源服务端的选中表现，当处理响应的时候。注意，取决于状态码语义，给定响应选中的表现不需要和封装在响应负载的表现一样。

在一个状态改变请求的成功响应中，验证域描述新表现，替换之前选中的表现作为处理请求的结果。

比如，201（Created）响应的头部域中的 ETag 头部域传达新创建的资源的表现的实体标签，这样它可以用于接下来的条件请求去防止“更新丢失”问题 \[RFC7232\]。

| 头部域名称 | 定义在... |
| --- | --- |
| ETag | \[RFC7232\] 的章节 2.3 |
| Last-Modified | \[RFC7232\] 的章节 2.2 |

### 7.3 认证邀请

认证邀请指示客户端在接下来的请求中可以用什么机制来提供认证凭证。

| 头部域名称 | 定义在... |
| --- | --- |
| WWW-Authenticate | \[RFC7235\] 的章节 4.1 |
| Proxy-Authenticate | \[RFC7235\] 的章节 4.3 |

### 7.4 响应上下文

剩下的头部域提供更多关于目标资源的信息，为潜在的后续请求使用。  
\| 头部域名称 \| 定义在... \|  
\| - \| - \|  
\| Accept-Ranges \| \[RFC7233\] 的章节 2.3 \|  
\| Allow \| 章节 7.4.1 \|  
\| Server \| 章节 7.4.2 \|

### 7.4.1 Allow

“Allow”头部域列出了目标资源支持的一系列方法。这个域的目的是严格的通知接收者资源关联的有效的请求方法。

```
    Allow   = #method
```

使用栗子：

```
    Allow: GET，HEAD，PUT
```

真实的允许的方法集合是源服务端针对每一次请求定义的。一个源服务端必须生成一个 Allow 域在一个 405（Method Not Allowed）响应，并且可能可能在任何其他响应中也这么做。一个空的 Allow 域值指示资源不允许方法，可能出现在 405 响应，如果资源被配置为临时不可用。

代理必须不修改 Allow 头部域 = 它不需要理解所有指定的方法为了去处理他们，基于通用消息处理规则。

### 7.4.2 Server

“Server”头部域包含源服务端处理请求使用的软件的信息，通常用于客户端帮助表示报告互操作性问题的范围，解决或者跳转请求去避免特定服务限制，为分析服务或者操作系统关联使用。

```
    Server = product *( RWS ( product / comment ) )
```

Server 域值由一个或者多个产品标识构成，每一个跟随 0 个或者多个评论（\[RFC7230\] 的章节 3.2），他们集合起来标识源服务器的软件和他重要的子馋哦。为了方便，产品标识符按他们标识服务端软件的重要性降序排列。每一个产品标识符由名字和可选的版本构成，正如章节 5.5.3 定义。

栗子：

```
    Server: CERN/3.0 libwww/2.17
```

一个服务端应该不生成一个 Server 域包含不需要的细粒度的细节，并且应该限制额外的第三方产品。过常或者详细的 Server 域值增加响应延迟和潜在披露内部实现细节可能导致（细微）攻击者更加容易找出和明确知道安全漏洞。

### 8. IANA 注意事项

### 8.1 方法注册

### 8.2 状态码注册

### 8.3 头部域注册

### 8.4 内容码注册

### 9. 安全注意事项

### 9.1. 基于文件和路径名的攻击

### 9.2. 基于命令，码，或者查询注入的攻击

### 9.3. 个人信息披露

### 9.4. URI 中敏感信息披露

### 9.5. 重定向后片段披露

### 9.6. 产品信息披露

### 9.7. 浏览器指纹

### 10. 致谢

### 11. 引用

### 附录 A. HTTP 和 MIME 之间的不同

### 附录 B. RFC 2616 之后的改变

### 附录 C. 导入的 ABNF

### 附录 D. ABNF 集合



